// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: log_metadata.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Empty } from "./google/protobuf/empty.js";
import { Timestamp } from "./google/protobuf/timestamp.js";
import { messageTypeRegistry } from "./typeRegistry.js";

export const protobufPackage = "wings.v1.log_metadata";

export interface CommitFolioRequest {
  $type: "wings.v1.log_metadata.CommitFolioRequest";
  readonly namespace: string;
  readonly fileRef: string;
  readonly pages: readonly CommitPageRequest[];
}

export interface CommitPageRequest {
  $type: "wings.v1.log_metadata.CommitPageRequest";
  readonly topic: string;
  readonly partition?: PartitionValue | undefined;
  readonly numMessages: number;
  readonly offsetBytes: bigint;
  readonly batchSizeBytes: bigint;
  readonly batches: readonly CommitBatchRequest[];
}

export interface CommitBatchRequest {
  $type: "wings.v1.log_metadata.CommitBatchRequest";
  /** / The requested timestamp (if any) of the batch. */
  readonly timestamp?:
    | Date
    | undefined;
  /** / The number of messages in the batch. */
  readonly numMessages: number;
}

export interface CommitFolioResponse {
  $type: "wings.v1.log_metadata.CommitFolioResponse";
  readonly pages: readonly CommitPageResponse[];
}

export interface CommitPageResponse {
  $type: "wings.v1.log_metadata.CommitPageResponse";
  readonly topic: string;
  readonly partition?: PartitionValue | undefined;
  readonly batches: readonly CommittedBatch[];
}

export interface GetLogLocationRequest {
  $type: "wings.v1.log_metadata.GetLogLocationRequest";
  readonly topic: string;
  readonly partition?: PartitionValue | undefined;
  readonly deadline: Date | undefined;
  readonly location?: { readonly $case: "offset"; readonly offset: bigint } | undefined;
}

export interface GetLogLocationResponse {
  $type: "wings.v1.log_metadata.GetLogLocationResponse";
  readonly location?: { readonly $case: "folioLocation"; readonly folioLocation: FolioLocation } | undefined;
}

export interface FolioLocation {
  $type: "wings.v1.log_metadata.FolioLocation";
  readonly fileRef: string;
  readonly offsetBytes: bigint;
  readonly sizeBytes: bigint;
  readonly batches: readonly CommittedBatch[];
}

export interface ListPartitionsRequest {
  $type: "wings.v1.log_metadata.ListPartitionsRequest";
  readonly topic: string;
  readonly pageSize?: number | undefined;
  readonly pageToken?: string | undefined;
}

export interface ListPartitionsResponse {
  $type: "wings.v1.log_metadata.ListPartitionsResponse";
  readonly partitions: readonly PartitionMetadata[];
  readonly nextPageToken?: string | undefined;
}

export interface PartitionMetadata {
  $type: "wings.v1.log_metadata.PartitionMetadata";
  readonly value?: PartitionValue | undefined;
  readonly endOffset: LogOffset | undefined;
}

export interface CommittedBatch {
  $type: "wings.v1.log_metadata.CommittedBatch";
  readonly result?: { readonly $case: "accepted"; readonly accepted: CommittedBatch_Accepted } | {
    readonly $case: "rejected";
    readonly rejected: CommittedBatch_Rejected;
  } | undefined;
}

export interface CommittedBatch_Accepted {
  $type: "wings.v1.log_metadata.CommittedBatch.Accepted";
  /** / The offset assigned to the first message in the batch. */
  readonly startOffset: bigint;
  /** / The offset assigned to the last message in the batch. */
  readonly endOffset: bigint;
  /** / The timestamp assigned to the batch. */
  readonly timestamp: Date | undefined;
}

export interface CommittedBatch_Rejected {
  $type: "wings.v1.log_metadata.CommittedBatch.Rejected";
  /** How many messages were rejected. */
  readonly numMessages: number;
}

export interface LogOffset {
  $type: "wings.v1.log_metadata.LogOffset";
  readonly offset: bigint;
  readonly timestamp: Date | undefined;
}

export interface PartitionValue {
  $type: "wings.v1.log_metadata.PartitionValue";
  readonly value?:
    | { readonly $case: "nullValue"; readonly nullValue: Empty }
    | { readonly $case: "int8Value"; readonly int8Value: number }
    | { readonly $case: "int16Value"; readonly int16Value: number }
    | { readonly $case: "int32Value"; readonly int32Value: number }
    | { readonly $case: "int64Value"; readonly int64Value: bigint }
    | { readonly $case: "uint8Value"; readonly uint8Value: number }
    | { readonly $case: "uint16Value"; readonly uint16Value: number }
    | { readonly $case: "uint32Value"; readonly uint32Value: number }
    | { readonly $case: "uint64Value"; readonly uint64Value: bigint }
    | { readonly $case: "stringValue"; readonly stringValue: string }
    | { readonly $case: "bytesValue"; readonly bytesValue: Uint8Array }
    | { readonly $case: "boolValue"; readonly boolValue: boolean }
    | undefined;
}

function createBaseCommitFolioRequest(): CommitFolioRequest {
  return { $type: "wings.v1.log_metadata.CommitFolioRequest", namespace: "", fileRef: "", pages: [] };
}

export const CommitFolioRequest: MessageFns<CommitFolioRequest, "wings.v1.log_metadata.CommitFolioRequest"> = {
  $type: "wings.v1.log_metadata.CommitFolioRequest" as const,

  encode(message: CommitFolioRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.namespace !== "") {
      writer.uint32(10).string(message.namespace);
    }
    if (message.fileRef !== "") {
      writer.uint32(18).string(message.fileRef);
    }
    for (const v of message.pages) {
      CommitPageRequest.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommitFolioRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitFolioRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fileRef = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pages.push(CommitPageRequest.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommitFolioRequest {
    return {
      $type: CommitFolioRequest.$type,
      namespace: isSet(object.namespace) ? globalThis.String(object.namespace) : "",
      fileRef: isSet(object.fileRef) ? globalThis.String(object.fileRef) : "",
      pages: globalThis.Array.isArray(object?.pages) ? object.pages.map((e: any) => CommitPageRequest.fromJSON(e)) : [],
    };
  },

  toJSON(message: CommitFolioRequest): unknown {
    const obj: any = {};
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.fileRef !== "") {
      obj.fileRef = message.fileRef;
    }
    if (message.pages?.length) {
      obj.pages = message.pages.map((e) => CommitPageRequest.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommitFolioRequest>, I>>(base?: I): CommitFolioRequest {
    return CommitFolioRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommitFolioRequest>, I>>(object: I): CommitFolioRequest {
    const message = createBaseCommitFolioRequest() as any;
    message.namespace = object.namespace ?? "";
    message.fileRef = object.fileRef ?? "";
    message.pages = object.pages?.map((e) => CommitPageRequest.fromPartial(e)) || [];
    return message;
  },
};

messageTypeRegistry.set(CommitFolioRequest.$type, CommitFolioRequest);

function createBaseCommitPageRequest(): CommitPageRequest {
  return {
    $type: "wings.v1.log_metadata.CommitPageRequest",
    topic: "",
    partition: undefined,
    numMessages: 0,
    offsetBytes: 0n,
    batchSizeBytes: 0n,
    batches: [],
  };
}

export const CommitPageRequest: MessageFns<CommitPageRequest, "wings.v1.log_metadata.CommitPageRequest"> = {
  $type: "wings.v1.log_metadata.CommitPageRequest" as const,

  encode(message: CommitPageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topic !== "") {
      writer.uint32(10).string(message.topic);
    }
    if (message.partition !== undefined) {
      PartitionValue.encode(message.partition, writer.uint32(18).fork()).join();
    }
    if (message.numMessages !== 0) {
      writer.uint32(24).uint32(message.numMessages);
    }
    if (message.offsetBytes !== 0n) {
      if (BigInt.asUintN(64, message.offsetBytes) !== message.offsetBytes) {
        throw new globalThis.Error("value provided for field message.offsetBytes of type uint64 too large");
      }
      writer.uint32(32).uint64(message.offsetBytes);
    }
    if (message.batchSizeBytes !== 0n) {
      if (BigInt.asUintN(64, message.batchSizeBytes) !== message.batchSizeBytes) {
        throw new globalThis.Error("value provided for field message.batchSizeBytes of type uint64 too large");
      }
      writer.uint32(40).uint64(message.batchSizeBytes);
    }
    for (const v of message.batches) {
      CommitBatchRequest.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommitPageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitPageRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.topic = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.partition = PartitionValue.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.numMessages = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.offsetBytes = reader.uint64() as bigint;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.batchSizeBytes = reader.uint64() as bigint;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.batches.push(CommitBatchRequest.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommitPageRequest {
    return {
      $type: CommitPageRequest.$type,
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      partition: isSet(object.partition) ? PartitionValue.fromJSON(object.partition) : undefined,
      numMessages: isSet(object.numMessages) ? globalThis.Number(object.numMessages) : 0,
      offsetBytes: isSet(object.offsetBytes) ? BigInt(object.offsetBytes) : 0n,
      batchSizeBytes: isSet(object.batchSizeBytes) ? BigInt(object.batchSizeBytes) : 0n,
      batches: globalThis.Array.isArray(object?.batches)
        ? object.batches.map((e: any) => CommitBatchRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CommitPageRequest): unknown {
    const obj: any = {};
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.partition !== undefined) {
      obj.partition = PartitionValue.toJSON(message.partition);
    }
    if (message.numMessages !== 0) {
      obj.numMessages = Math.round(message.numMessages);
    }
    if (message.offsetBytes !== 0n) {
      obj.offsetBytes = message.offsetBytes.toString();
    }
    if (message.batchSizeBytes !== 0n) {
      obj.batchSizeBytes = message.batchSizeBytes.toString();
    }
    if (message.batches?.length) {
      obj.batches = message.batches.map((e) => CommitBatchRequest.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommitPageRequest>, I>>(base?: I): CommitPageRequest {
    return CommitPageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommitPageRequest>, I>>(object: I): CommitPageRequest {
    const message = createBaseCommitPageRequest() as any;
    message.topic = object.topic ?? "";
    message.partition = (object.partition !== undefined && object.partition !== null)
      ? PartitionValue.fromPartial(object.partition)
      : undefined;
    message.numMessages = object.numMessages ?? 0;
    message.offsetBytes = object.offsetBytes ?? 0n;
    message.batchSizeBytes = object.batchSizeBytes ?? 0n;
    message.batches = object.batches?.map((e) => CommitBatchRequest.fromPartial(e)) || [];
    return message;
  },
};

messageTypeRegistry.set(CommitPageRequest.$type, CommitPageRequest);

function createBaseCommitBatchRequest(): CommitBatchRequest {
  return { $type: "wings.v1.log_metadata.CommitBatchRequest", timestamp: undefined, numMessages: 0 };
}

export const CommitBatchRequest: MessageFns<CommitBatchRequest, "wings.v1.log_metadata.CommitBatchRequest"> = {
  $type: "wings.v1.log_metadata.CommitBatchRequest" as const,

  encode(message: CommitBatchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(10).fork()).join();
    }
    if (message.numMessages !== 0) {
      writer.uint32(16).uint32(message.numMessages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommitBatchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitBatchRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.numMessages = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommitBatchRequest {
    return {
      $type: CommitBatchRequest.$type,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      numMessages: isSet(object.numMessages) ? globalThis.Number(object.numMessages) : 0,
    };
  },

  toJSON(message: CommitBatchRequest): unknown {
    const obj: any = {};
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.numMessages !== 0) {
      obj.numMessages = Math.round(message.numMessages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommitBatchRequest>, I>>(base?: I): CommitBatchRequest {
    return CommitBatchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommitBatchRequest>, I>>(object: I): CommitBatchRequest {
    const message = createBaseCommitBatchRequest() as any;
    message.timestamp = object.timestamp ?? undefined;
    message.numMessages = object.numMessages ?? 0;
    return message;
  },
};

messageTypeRegistry.set(CommitBatchRequest.$type, CommitBatchRequest);

function createBaseCommitFolioResponse(): CommitFolioResponse {
  return { $type: "wings.v1.log_metadata.CommitFolioResponse", pages: [] };
}

export const CommitFolioResponse: MessageFns<CommitFolioResponse, "wings.v1.log_metadata.CommitFolioResponse"> = {
  $type: "wings.v1.log_metadata.CommitFolioResponse" as const,

  encode(message: CommitFolioResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pages) {
      CommitPageResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommitFolioResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitFolioResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pages.push(CommitPageResponse.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommitFolioResponse {
    return {
      $type: CommitFolioResponse.$type,
      pages: globalThis.Array.isArray(object?.pages)
        ? object.pages.map((e: any) => CommitPageResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CommitFolioResponse): unknown {
    const obj: any = {};
    if (message.pages?.length) {
      obj.pages = message.pages.map((e) => CommitPageResponse.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommitFolioResponse>, I>>(base?: I): CommitFolioResponse {
    return CommitFolioResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommitFolioResponse>, I>>(object: I): CommitFolioResponse {
    const message = createBaseCommitFolioResponse() as any;
    message.pages = object.pages?.map((e) => CommitPageResponse.fromPartial(e)) || [];
    return message;
  },
};

messageTypeRegistry.set(CommitFolioResponse.$type, CommitFolioResponse);

function createBaseCommitPageResponse(): CommitPageResponse {
  return { $type: "wings.v1.log_metadata.CommitPageResponse", topic: "", partition: undefined, batches: [] };
}

export const CommitPageResponse: MessageFns<CommitPageResponse, "wings.v1.log_metadata.CommitPageResponse"> = {
  $type: "wings.v1.log_metadata.CommitPageResponse" as const,

  encode(message: CommitPageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topic !== "") {
      writer.uint32(10).string(message.topic);
    }
    if (message.partition !== undefined) {
      PartitionValue.encode(message.partition, writer.uint32(18).fork()).join();
    }
    for (const v of message.batches) {
      CommittedBatch.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommitPageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitPageResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.topic = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.partition = PartitionValue.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.batches.push(CommittedBatch.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommitPageResponse {
    return {
      $type: CommitPageResponse.$type,
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      partition: isSet(object.partition) ? PartitionValue.fromJSON(object.partition) : undefined,
      batches: globalThis.Array.isArray(object?.batches)
        ? object.batches.map((e: any) => CommittedBatch.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CommitPageResponse): unknown {
    const obj: any = {};
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.partition !== undefined) {
      obj.partition = PartitionValue.toJSON(message.partition);
    }
    if (message.batches?.length) {
      obj.batches = message.batches.map((e) => CommittedBatch.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommitPageResponse>, I>>(base?: I): CommitPageResponse {
    return CommitPageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommitPageResponse>, I>>(object: I): CommitPageResponse {
    const message = createBaseCommitPageResponse() as any;
    message.topic = object.topic ?? "";
    message.partition = (object.partition !== undefined && object.partition !== null)
      ? PartitionValue.fromPartial(object.partition)
      : undefined;
    message.batches = object.batches?.map((e) => CommittedBatch.fromPartial(e)) || [];
    return message;
  },
};

messageTypeRegistry.set(CommitPageResponse.$type, CommitPageResponse);

function createBaseGetLogLocationRequest(): GetLogLocationRequest {
  return {
    $type: "wings.v1.log_metadata.GetLogLocationRequest",
    topic: "",
    partition: undefined,
    deadline: undefined,
    location: undefined,
  };
}

export const GetLogLocationRequest: MessageFns<GetLogLocationRequest, "wings.v1.log_metadata.GetLogLocationRequest"> = {
  $type: "wings.v1.log_metadata.GetLogLocationRequest" as const,

  encode(message: GetLogLocationRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topic !== "") {
      writer.uint32(10).string(message.topic);
    }
    if (message.partition !== undefined) {
      PartitionValue.encode(message.partition, writer.uint32(18).fork()).join();
    }
    if (message.deadline !== undefined) {
      Timestamp.encode(toTimestamp(message.deadline), writer.uint32(26).fork()).join();
    }
    switch (message.location?.$case) {
      case "offset":
        if (BigInt.asUintN(64, message.location.offset) !== message.location.offset) {
          throw new globalThis.Error("value provided for field message.location.offset of type uint64 too large");
        }
        writer.uint32(32).uint64(message.location.offset);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLogLocationRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLogLocationRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.topic = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.partition = PartitionValue.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deadline = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.location = { $case: "offset", offset: reader.uint64() as bigint };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLogLocationRequest {
    return {
      $type: GetLogLocationRequest.$type,
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      partition: isSet(object.partition) ? PartitionValue.fromJSON(object.partition) : undefined,
      deadline: isSet(object.deadline) ? fromJsonTimestamp(object.deadline) : undefined,
      location: isSet(object.offset) ? { $case: "offset", offset: BigInt(object.offset) } : undefined,
    };
  },

  toJSON(message: GetLogLocationRequest): unknown {
    const obj: any = {};
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.partition !== undefined) {
      obj.partition = PartitionValue.toJSON(message.partition);
    }
    if (message.deadline !== undefined) {
      obj.deadline = message.deadline.toISOString();
    }
    if (message.location?.$case === "offset") {
      obj.offset = message.location.offset.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLogLocationRequest>, I>>(base?: I): GetLogLocationRequest {
    return GetLogLocationRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLogLocationRequest>, I>>(object: I): GetLogLocationRequest {
    const message = createBaseGetLogLocationRequest() as any;
    message.topic = object.topic ?? "";
    message.partition = (object.partition !== undefined && object.partition !== null)
      ? PartitionValue.fromPartial(object.partition)
      : undefined;
    message.deadline = object.deadline ?? undefined;
    switch (object.location?.$case) {
      case "offset": {
        if (object.location?.offset !== undefined && object.location?.offset !== null) {
          message.location = { $case: "offset", offset: object.location.offset };
        }
        break;
      }
    }
    return message;
  },
};

messageTypeRegistry.set(GetLogLocationRequest.$type, GetLogLocationRequest);

function createBaseGetLogLocationResponse(): GetLogLocationResponse {
  return { $type: "wings.v1.log_metadata.GetLogLocationResponse", location: undefined };
}

export const GetLogLocationResponse: MessageFns<
  GetLogLocationResponse,
  "wings.v1.log_metadata.GetLogLocationResponse"
> = {
  $type: "wings.v1.log_metadata.GetLogLocationResponse" as const,

  encode(message: GetLogLocationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.location?.$case) {
      case "folioLocation":
        FolioLocation.encode(message.location.folioLocation, writer.uint32(10).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLogLocationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLogLocationResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.location = { $case: "folioLocation", folioLocation: FolioLocation.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLogLocationResponse {
    return {
      $type: GetLogLocationResponse.$type,
      location: isSet(object.folioLocation)
        ? { $case: "folioLocation", folioLocation: FolioLocation.fromJSON(object.folioLocation) }
        : undefined,
    };
  },

  toJSON(message: GetLogLocationResponse): unknown {
    const obj: any = {};
    if (message.location?.$case === "folioLocation") {
      obj.folioLocation = FolioLocation.toJSON(message.location.folioLocation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetLogLocationResponse>, I>>(base?: I): GetLogLocationResponse {
    return GetLogLocationResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetLogLocationResponse>, I>>(object: I): GetLogLocationResponse {
    const message = createBaseGetLogLocationResponse() as any;
    switch (object.location?.$case) {
      case "folioLocation": {
        if (object.location?.folioLocation !== undefined && object.location?.folioLocation !== null) {
          message.location = {
            $case: "folioLocation",
            folioLocation: FolioLocation.fromPartial(object.location.folioLocation),
          };
        }
        break;
      }
    }
    return message;
  },
};

messageTypeRegistry.set(GetLogLocationResponse.$type, GetLogLocationResponse);

function createBaseFolioLocation(): FolioLocation {
  return { $type: "wings.v1.log_metadata.FolioLocation", fileRef: "", offsetBytes: 0n, sizeBytes: 0n, batches: [] };
}

export const FolioLocation: MessageFns<FolioLocation, "wings.v1.log_metadata.FolioLocation"> = {
  $type: "wings.v1.log_metadata.FolioLocation" as const,

  encode(message: FolioLocation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fileRef !== "") {
      writer.uint32(10).string(message.fileRef);
    }
    if (message.offsetBytes !== 0n) {
      if (BigInt.asUintN(64, message.offsetBytes) !== message.offsetBytes) {
        throw new globalThis.Error("value provided for field message.offsetBytes of type uint64 too large");
      }
      writer.uint32(16).uint64(message.offsetBytes);
    }
    if (message.sizeBytes !== 0n) {
      if (BigInt.asUintN(64, message.sizeBytes) !== message.sizeBytes) {
        throw new globalThis.Error("value provided for field message.sizeBytes of type uint64 too large");
      }
      writer.uint32(24).uint64(message.sizeBytes);
    }
    for (const v of message.batches) {
      CommittedBatch.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FolioLocation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFolioLocation() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fileRef = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.offsetBytes = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sizeBytes = reader.uint64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.batches.push(CommittedBatch.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FolioLocation {
    return {
      $type: FolioLocation.$type,
      fileRef: isSet(object.fileRef) ? globalThis.String(object.fileRef) : "",
      offsetBytes: isSet(object.offsetBytes) ? BigInt(object.offsetBytes) : 0n,
      sizeBytes: isSet(object.sizeBytes) ? BigInt(object.sizeBytes) : 0n,
      batches: globalThis.Array.isArray(object?.batches)
        ? object.batches.map((e: any) => CommittedBatch.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FolioLocation): unknown {
    const obj: any = {};
    if (message.fileRef !== "") {
      obj.fileRef = message.fileRef;
    }
    if (message.offsetBytes !== 0n) {
      obj.offsetBytes = message.offsetBytes.toString();
    }
    if (message.sizeBytes !== 0n) {
      obj.sizeBytes = message.sizeBytes.toString();
    }
    if (message.batches?.length) {
      obj.batches = message.batches.map((e) => CommittedBatch.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FolioLocation>, I>>(base?: I): FolioLocation {
    return FolioLocation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FolioLocation>, I>>(object: I): FolioLocation {
    const message = createBaseFolioLocation() as any;
    message.fileRef = object.fileRef ?? "";
    message.offsetBytes = object.offsetBytes ?? 0n;
    message.sizeBytes = object.sizeBytes ?? 0n;
    message.batches = object.batches?.map((e) => CommittedBatch.fromPartial(e)) || [];
    return message;
  },
};

messageTypeRegistry.set(FolioLocation.$type, FolioLocation);

function createBaseListPartitionsRequest(): ListPartitionsRequest {
  return { $type: "wings.v1.log_metadata.ListPartitionsRequest", topic: "", pageSize: undefined, pageToken: undefined };
}

export const ListPartitionsRequest: MessageFns<ListPartitionsRequest, "wings.v1.log_metadata.ListPartitionsRequest"> = {
  $type: "wings.v1.log_metadata.ListPartitionsRequest" as const,

  encode(message: ListPartitionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topic !== "") {
      writer.uint32(10).string(message.topic);
    }
    if (message.pageSize !== undefined) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPartitionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPartitionsRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.topic = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPartitionsRequest {
    return {
      $type: ListPartitionsRequest.$type,
      topic: isSet(object.topic) ? globalThis.String(object.topic) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : undefined,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : undefined,
    };
  },

  toJSON(message: ListPartitionsRequest): unknown {
    const obj: any = {};
    if (message.topic !== "") {
      obj.topic = message.topic;
    }
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPartitionsRequest>, I>>(base?: I): ListPartitionsRequest {
    return ListPartitionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPartitionsRequest>, I>>(object: I): ListPartitionsRequest {
    const message = createBaseListPartitionsRequest() as any;
    message.topic = object.topic ?? "";
    message.pageSize = object.pageSize ?? undefined;
    message.pageToken = object.pageToken ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ListPartitionsRequest.$type, ListPartitionsRequest);

function createBaseListPartitionsResponse(): ListPartitionsResponse {
  return { $type: "wings.v1.log_metadata.ListPartitionsResponse", partitions: [], nextPageToken: undefined };
}

export const ListPartitionsResponse: MessageFns<
  ListPartitionsResponse,
  "wings.v1.log_metadata.ListPartitionsResponse"
> = {
  $type: "wings.v1.log_metadata.ListPartitionsResponse" as const,

  encode(message: ListPartitionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.partitions) {
      PartitionMetadata.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== undefined) {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPartitionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPartitionsResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.partitions.push(PartitionMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPartitionsResponse {
    return {
      $type: ListPartitionsResponse.$type,
      partitions: globalThis.Array.isArray(object?.partitions)
        ? object.partitions.map((e: any) => PartitionMetadata.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : undefined,
    };
  },

  toJSON(message: ListPartitionsResponse): unknown {
    const obj: any = {};
    if (message.partitions?.length) {
      obj.partitions = message.partitions.map((e) => PartitionMetadata.toJSON(e));
    }
    if (message.nextPageToken !== undefined) {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListPartitionsResponse>, I>>(base?: I): ListPartitionsResponse {
    return ListPartitionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListPartitionsResponse>, I>>(object: I): ListPartitionsResponse {
    const message = createBaseListPartitionsResponse() as any;
    message.partitions = object.partitions?.map((e) => PartitionMetadata.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ListPartitionsResponse.$type, ListPartitionsResponse);

function createBasePartitionMetadata(): PartitionMetadata {
  return { $type: "wings.v1.log_metadata.PartitionMetadata", value: undefined, endOffset: undefined };
}

export const PartitionMetadata: MessageFns<PartitionMetadata, "wings.v1.log_metadata.PartitionMetadata"> = {
  $type: "wings.v1.log_metadata.PartitionMetadata" as const,

  encode(message: PartitionMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      PartitionValue.encode(message.value, writer.uint32(10).fork()).join();
    }
    if (message.endOffset !== undefined) {
      LogOffset.encode(message.endOffset, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PartitionMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePartitionMetadata() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = PartitionValue.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.endOffset = LogOffset.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PartitionMetadata {
    return {
      $type: PartitionMetadata.$type,
      value: isSet(object.value) ? PartitionValue.fromJSON(object.value) : undefined,
      endOffset: isSet(object.endOffset) ? LogOffset.fromJSON(object.endOffset) : undefined,
    };
  },

  toJSON(message: PartitionMetadata): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = PartitionValue.toJSON(message.value);
    }
    if (message.endOffset !== undefined) {
      obj.endOffset = LogOffset.toJSON(message.endOffset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PartitionMetadata>, I>>(base?: I): PartitionMetadata {
    return PartitionMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PartitionMetadata>, I>>(object: I): PartitionMetadata {
    const message = createBasePartitionMetadata() as any;
    message.value = (object.value !== undefined && object.value !== null)
      ? PartitionValue.fromPartial(object.value)
      : undefined;
    message.endOffset = (object.endOffset !== undefined && object.endOffset !== null)
      ? LogOffset.fromPartial(object.endOffset)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(PartitionMetadata.$type, PartitionMetadata);

function createBaseCommittedBatch(): CommittedBatch {
  return { $type: "wings.v1.log_metadata.CommittedBatch", result: undefined };
}

export const CommittedBatch: MessageFns<CommittedBatch, "wings.v1.log_metadata.CommittedBatch"> = {
  $type: "wings.v1.log_metadata.CommittedBatch" as const,

  encode(message: CommittedBatch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.result?.$case) {
      case "accepted":
        CommittedBatch_Accepted.encode(message.result.accepted, writer.uint32(10).fork()).join();
        break;
      case "rejected":
        CommittedBatch_Rejected.encode(message.result.rejected, writer.uint32(18).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommittedBatch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommittedBatch() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.result = { $case: "accepted", accepted: CommittedBatch_Accepted.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = { $case: "rejected", rejected: CommittedBatch_Rejected.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommittedBatch {
    return {
      $type: CommittedBatch.$type,
      result: isSet(object.accepted)
        ? { $case: "accepted", accepted: CommittedBatch_Accepted.fromJSON(object.accepted) }
        : isSet(object.rejected)
        ? { $case: "rejected", rejected: CommittedBatch_Rejected.fromJSON(object.rejected) }
        : undefined,
    };
  },

  toJSON(message: CommittedBatch): unknown {
    const obj: any = {};
    if (message.result?.$case === "accepted") {
      obj.accepted = CommittedBatch_Accepted.toJSON(message.result.accepted);
    } else if (message.result?.$case === "rejected") {
      obj.rejected = CommittedBatch_Rejected.toJSON(message.result.rejected);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommittedBatch>, I>>(base?: I): CommittedBatch {
    return CommittedBatch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommittedBatch>, I>>(object: I): CommittedBatch {
    const message = createBaseCommittedBatch() as any;
    switch (object.result?.$case) {
      case "accepted": {
        if (object.result?.accepted !== undefined && object.result?.accepted !== null) {
          message.result = { $case: "accepted", accepted: CommittedBatch_Accepted.fromPartial(object.result.accepted) };
        }
        break;
      }
      case "rejected": {
        if (object.result?.rejected !== undefined && object.result?.rejected !== null) {
          message.result = { $case: "rejected", rejected: CommittedBatch_Rejected.fromPartial(object.result.rejected) };
        }
        break;
      }
    }
    return message;
  },
};

messageTypeRegistry.set(CommittedBatch.$type, CommittedBatch);

function createBaseCommittedBatch_Accepted(): CommittedBatch_Accepted {
  return {
    $type: "wings.v1.log_metadata.CommittedBatch.Accepted",
    startOffset: 0n,
    endOffset: 0n,
    timestamp: undefined,
  };
}

export const CommittedBatch_Accepted: MessageFns<
  CommittedBatch_Accepted,
  "wings.v1.log_metadata.CommittedBatch.Accepted"
> = {
  $type: "wings.v1.log_metadata.CommittedBatch.Accepted" as const,

  encode(message: CommittedBatch_Accepted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startOffset !== 0n) {
      if (BigInt.asUintN(64, message.startOffset) !== message.startOffset) {
        throw new globalThis.Error("value provided for field message.startOffset of type uint64 too large");
      }
      writer.uint32(8).uint64(message.startOffset);
    }
    if (message.endOffset !== 0n) {
      if (BigInt.asUintN(64, message.endOffset) !== message.endOffset) {
        throw new globalThis.Error("value provided for field message.endOffset of type uint64 too large");
      }
      writer.uint32(16).uint64(message.endOffset);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommittedBatch_Accepted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommittedBatch_Accepted() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.startOffset = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.endOffset = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommittedBatch_Accepted {
    return {
      $type: CommittedBatch_Accepted.$type,
      startOffset: isSet(object.startOffset) ? BigInt(object.startOffset) : 0n,
      endOffset: isSet(object.endOffset) ? BigInt(object.endOffset) : 0n,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
    };
  },

  toJSON(message: CommittedBatch_Accepted): unknown {
    const obj: any = {};
    if (message.startOffset !== 0n) {
      obj.startOffset = message.startOffset.toString();
    }
    if (message.endOffset !== 0n) {
      obj.endOffset = message.endOffset.toString();
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommittedBatch_Accepted>, I>>(base?: I): CommittedBatch_Accepted {
    return CommittedBatch_Accepted.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommittedBatch_Accepted>, I>>(object: I): CommittedBatch_Accepted {
    const message = createBaseCommittedBatch_Accepted() as any;
    message.startOffset = object.startOffset ?? 0n;
    message.endOffset = object.endOffset ?? 0n;
    message.timestamp = object.timestamp ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(CommittedBatch_Accepted.$type, CommittedBatch_Accepted);

function createBaseCommittedBatch_Rejected(): CommittedBatch_Rejected {
  return { $type: "wings.v1.log_metadata.CommittedBatch.Rejected", numMessages: 0 };
}

export const CommittedBatch_Rejected: MessageFns<
  CommittedBatch_Rejected,
  "wings.v1.log_metadata.CommittedBatch.Rejected"
> = {
  $type: "wings.v1.log_metadata.CommittedBatch.Rejected" as const,

  encode(message: CommittedBatch_Rejected, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.numMessages !== 0) {
      writer.uint32(8).uint32(message.numMessages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommittedBatch_Rejected {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommittedBatch_Rejected() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.numMessages = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommittedBatch_Rejected {
    return {
      $type: CommittedBatch_Rejected.$type,
      numMessages: isSet(object.numMessages) ? globalThis.Number(object.numMessages) : 0,
    };
  },

  toJSON(message: CommittedBatch_Rejected): unknown {
    const obj: any = {};
    if (message.numMessages !== 0) {
      obj.numMessages = Math.round(message.numMessages);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommittedBatch_Rejected>, I>>(base?: I): CommittedBatch_Rejected {
    return CommittedBatch_Rejected.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommittedBatch_Rejected>, I>>(object: I): CommittedBatch_Rejected {
    const message = createBaseCommittedBatch_Rejected() as any;
    message.numMessages = object.numMessages ?? 0;
    return message;
  },
};

messageTypeRegistry.set(CommittedBatch_Rejected.$type, CommittedBatch_Rejected);

function createBaseLogOffset(): LogOffset {
  return { $type: "wings.v1.log_metadata.LogOffset", offset: 0n, timestamp: undefined };
}

export const LogOffset: MessageFns<LogOffset, "wings.v1.log_metadata.LogOffset"> = {
  $type: "wings.v1.log_metadata.LogOffset" as const,

  encode(message: LogOffset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offset !== 0n) {
      if (BigInt.asUintN(64, message.offset) !== message.offset) {
        throw new globalThis.Error("value provided for field message.offset of type uint64 too large");
      }
      writer.uint32(8).uint64(message.offset);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogOffset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogOffset() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.offset = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogOffset {
    return {
      $type: LogOffset.$type,
      offset: isSet(object.offset) ? BigInt(object.offset) : 0n,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
    };
  },

  toJSON(message: LogOffset): unknown {
    const obj: any = {};
    if (message.offset !== 0n) {
      obj.offset = message.offset.toString();
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LogOffset>, I>>(base?: I): LogOffset {
    return LogOffset.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LogOffset>, I>>(object: I): LogOffset {
    const message = createBaseLogOffset() as any;
    message.offset = object.offset ?? 0n;
    message.timestamp = object.timestamp ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(LogOffset.$type, LogOffset);

function createBasePartitionValue(): PartitionValue {
  return { $type: "wings.v1.log_metadata.PartitionValue", value: undefined };
}

export const PartitionValue: MessageFns<PartitionValue, "wings.v1.log_metadata.PartitionValue"> = {
  $type: "wings.v1.log_metadata.PartitionValue" as const,

  encode(message: PartitionValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.value?.$case) {
      case "nullValue":
        Empty.encode(message.value.nullValue, writer.uint32(10).fork()).join();
        break;
      case "int8Value":
        writer.uint32(16).int32(message.value.int8Value);
        break;
      case "int16Value":
        writer.uint32(24).int32(message.value.int16Value);
        break;
      case "int32Value":
        writer.uint32(32).int32(message.value.int32Value);
        break;
      case "int64Value":
        if (BigInt.asIntN(64, message.value.int64Value) !== message.value.int64Value) {
          throw new globalThis.Error("value provided for field message.value.int64Value of type int64 too large");
        }
        writer.uint32(40).int64(message.value.int64Value);
        break;
      case "uint8Value":
        writer.uint32(48).uint32(message.value.uint8Value);
        break;
      case "uint16Value":
        writer.uint32(56).uint32(message.value.uint16Value);
        break;
      case "uint32Value":
        writer.uint32(64).uint32(message.value.uint32Value);
        break;
      case "uint64Value":
        if (BigInt.asUintN(64, message.value.uint64Value) !== message.value.uint64Value) {
          throw new globalThis.Error("value provided for field message.value.uint64Value of type uint64 too large");
        }
        writer.uint32(72).uint64(message.value.uint64Value);
        break;
      case "stringValue":
        writer.uint32(82).string(message.value.stringValue);
        break;
      case "bytesValue":
        writer.uint32(90).bytes(message.value.bytesValue);
        break;
      case "boolValue":
        writer.uint32(96).bool(message.value.boolValue);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PartitionValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePartitionValue() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = { $case: "nullValue", nullValue: Empty.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = { $case: "int8Value", int8Value: reader.int32() };
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.value = { $case: "int16Value", int16Value: reader.int32() };
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.value = { $case: "int32Value", int32Value: reader.int32() };
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.value = { $case: "int64Value", int64Value: reader.int64() as bigint };
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.value = { $case: "uint8Value", uint8Value: reader.uint32() };
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.value = { $case: "uint16Value", uint16Value: reader.uint32() };
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.value = { $case: "uint32Value", uint32Value: reader.uint32() };
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.value = { $case: "uint64Value", uint64Value: reader.uint64() as bigint };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.value = { $case: "stringValue", stringValue: reader.string() };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.value = { $case: "bytesValue", bytesValue: reader.bytes() };
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.value = { $case: "boolValue", boolValue: reader.bool() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PartitionValue {
    return {
      $type: PartitionValue.$type,
      value: isSet(object.nullValue)
        ? { $case: "nullValue", nullValue: Empty.fromJSON(object.nullValue) }
        : isSet(object.int8Value)
        ? { $case: "int8Value", int8Value: globalThis.Number(object.int8Value) }
        : isSet(object.int16Value)
        ? { $case: "int16Value", int16Value: globalThis.Number(object.int16Value) }
        : isSet(object.int32Value)
        ? { $case: "int32Value", int32Value: globalThis.Number(object.int32Value) }
        : isSet(object.int64Value)
        ? { $case: "int64Value", int64Value: BigInt(object.int64Value) }
        : isSet(object.uint8Value)
        ? { $case: "uint8Value", uint8Value: globalThis.Number(object.uint8Value) }
        : isSet(object.uint16Value)
        ? { $case: "uint16Value", uint16Value: globalThis.Number(object.uint16Value) }
        : isSet(object.uint32Value)
        ? { $case: "uint32Value", uint32Value: globalThis.Number(object.uint32Value) }
        : isSet(object.uint64Value)
        ? { $case: "uint64Value", uint64Value: BigInt(object.uint64Value) }
        : isSet(object.stringValue)
        ? { $case: "stringValue", stringValue: globalThis.String(object.stringValue) }
        : isSet(object.bytesValue)
        ? { $case: "bytesValue", bytesValue: bytesFromBase64(object.bytesValue) }
        : isSet(object.boolValue)
        ? { $case: "boolValue", boolValue: globalThis.Boolean(object.boolValue) }
        : undefined,
    };
  },

  toJSON(message: PartitionValue): unknown {
    const obj: any = {};
    if (message.value?.$case === "nullValue") {
      obj.nullValue = Empty.toJSON(message.value.nullValue);
    } else if (message.value?.$case === "int8Value") {
      obj.int8Value = Math.round(message.value.int8Value);
    } else if (message.value?.$case === "int16Value") {
      obj.int16Value = Math.round(message.value.int16Value);
    } else if (message.value?.$case === "int32Value") {
      obj.int32Value = Math.round(message.value.int32Value);
    } else if (message.value?.$case === "int64Value") {
      obj.int64Value = message.value.int64Value.toString();
    } else if (message.value?.$case === "uint8Value") {
      obj.uint8Value = Math.round(message.value.uint8Value);
    } else if (message.value?.$case === "uint16Value") {
      obj.uint16Value = Math.round(message.value.uint16Value);
    } else if (message.value?.$case === "uint32Value") {
      obj.uint32Value = Math.round(message.value.uint32Value);
    } else if (message.value?.$case === "uint64Value") {
      obj.uint64Value = message.value.uint64Value.toString();
    } else if (message.value?.$case === "stringValue") {
      obj.stringValue = message.value.stringValue;
    } else if (message.value?.$case === "bytesValue") {
      obj.bytesValue = base64FromBytes(message.value.bytesValue);
    } else if (message.value?.$case === "boolValue") {
      obj.boolValue = message.value.boolValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PartitionValue>, I>>(base?: I): PartitionValue {
    return PartitionValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PartitionValue>, I>>(object: I): PartitionValue {
    const message = createBasePartitionValue() as any;
    switch (object.value?.$case) {
      case "nullValue": {
        if (object.value?.nullValue !== undefined && object.value?.nullValue !== null) {
          message.value = { $case: "nullValue", nullValue: Empty.fromPartial(object.value.nullValue) };
        }
        break;
      }
      case "int8Value": {
        if (object.value?.int8Value !== undefined && object.value?.int8Value !== null) {
          message.value = { $case: "int8Value", int8Value: object.value.int8Value };
        }
        break;
      }
      case "int16Value": {
        if (object.value?.int16Value !== undefined && object.value?.int16Value !== null) {
          message.value = { $case: "int16Value", int16Value: object.value.int16Value };
        }
        break;
      }
      case "int32Value": {
        if (object.value?.int32Value !== undefined && object.value?.int32Value !== null) {
          message.value = { $case: "int32Value", int32Value: object.value.int32Value };
        }
        break;
      }
      case "int64Value": {
        if (object.value?.int64Value !== undefined && object.value?.int64Value !== null) {
          message.value = { $case: "int64Value", int64Value: object.value.int64Value };
        }
        break;
      }
      case "uint8Value": {
        if (object.value?.uint8Value !== undefined && object.value?.uint8Value !== null) {
          message.value = { $case: "uint8Value", uint8Value: object.value.uint8Value };
        }
        break;
      }
      case "uint16Value": {
        if (object.value?.uint16Value !== undefined && object.value?.uint16Value !== null) {
          message.value = { $case: "uint16Value", uint16Value: object.value.uint16Value };
        }
        break;
      }
      case "uint32Value": {
        if (object.value?.uint32Value !== undefined && object.value?.uint32Value !== null) {
          message.value = { $case: "uint32Value", uint32Value: object.value.uint32Value };
        }
        break;
      }
      case "uint64Value": {
        if (object.value?.uint64Value !== undefined && object.value?.uint64Value !== null) {
          message.value = { $case: "uint64Value", uint64Value: object.value.uint64Value };
        }
        break;
      }
      case "stringValue": {
        if (object.value?.stringValue !== undefined && object.value?.stringValue !== null) {
          message.value = { $case: "stringValue", stringValue: object.value.stringValue };
        }
        break;
      }
      case "bytesValue": {
        if (object.value?.bytesValue !== undefined && object.value?.bytesValue !== null) {
          message.value = { $case: "bytesValue", bytesValue: object.value.bytesValue };
        }
        break;
      }
      case "boolValue": {
        if (object.value?.boolValue !== undefined && object.value?.boolValue !== null) {
          message.value = { $case: "boolValue", boolValue: object.value.boolValue };
        }
        break;
      }
    }
    return message;
  },
};

messageTypeRegistry.set(PartitionValue.$type, PartitionValue);

export type LogMetadataServiceDefinition = typeof LogMetadataServiceDefinition;
export const LogMetadataServiceDefinition = {
  name: "LogMetadataService",
  fullName: "wings.v1.log_metadata.LogMetadataService",
  methods: {
    commitFolio: {
      name: "CommitFolio",
      requestType: CommitFolioRequest,
      requestStream: false,
      responseType: CommitFolioResponse,
      responseStream: false,
      options: {},
    },
    getLogLocation: {
      name: "GetLogLocation",
      requestType: GetLogLocationRequest,
      requestStream: false,
      responseType: GetLogLocationResponse,
      responseStream: false,
      options: {},
    },
    listPartitions: {
      name: "ListPartitions",
      requestType: ListPartitionsRequest,
      requestStream: false,
      responseType: ListPartitionsResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface LogMetadataServiceImplementation<CallContextExt = {}> {
  commitFolio(
    request: CommitFolioRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CommitFolioResponse>>;
  getLogLocation(
    request: GetLogLocationRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetLogLocationResponse>>;
  listPartitions(
    request: ListPartitionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListPartitionsResponse>>;
}

export interface LogMetadataServiceClient<CallOptionsExt = {}> {
  commitFolio(
    request: DeepPartial<CommitFolioRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CommitFolioResponse>;
  getLogLocation(
    request: DeepPartial<GetLogLocationRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetLogLocationResponse>;
  listPartitions(
    request: DeepPartial<ListPartitionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListPartitionsResponse>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { readonly $case: string }
    ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { readonly $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = BigInt(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { $type: "google.protobuf.Timestamp", seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds.toString()) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
