// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: cluster_metadata.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Empty } from "./google/protobuf/empty.js";
import { messageTypeRegistry } from "./typeRegistry.js";

export const protobufPackage = "wings.v1.cluster_metadata";

export interface CreateTenantRequest {
  $type: "wings.v1.cluster_metadata.CreateTenantRequest";
  /** The tenant id. */
  readonly tenantId: string;
  /** The tenant metadata. */
  readonly tenant: Tenant | undefined;
}

export interface GetTenantRequest {
  $type: "wings.v1.cluster_metadata.GetTenantRequest";
  /**
   * The tenant name.
   *
   * Format: tenants/{tenant}
   */
  readonly name: string;
}

export interface ListTenantsRequest {
  $type: "wings.v1.cluster_metadata.ListTenantsRequest";
  /**
   * The number of tenants to return.
   *
   * Default: 100
   * Maximum: 1000.
   */
  readonly pageSize?:
    | number
    | undefined;
  /** The continuation token. */
  readonly pageToken?: string | undefined;
}

export interface ListTenantsResponse {
  $type: "wings.v1.cluster_metadata.ListTenantsResponse";
  /** The tenants. */
  readonly tenants: readonly Tenant[];
  /** The continuation token. */
  readonly nextPageToken: string;
}

export interface DeleteTenantRequest {
  $type: "wings.v1.cluster_metadata.DeleteTenantRequest";
  /**
   * The tenant name.
   *
   * Format: tenants/{tenant}
   */
  readonly name: string;
}

export interface Tenant {
  $type: "wings.v1.cluster_metadata.Tenant";
  /**
   * The tenant name.
   *
   * Format: tenants/{tenant}
   */
  readonly name: string;
}

export interface CreateNamespaceRequest {
  $type: "wings.v1.cluster_metadata.CreateNamespaceRequest";
  /**
   * The tenant that owns the namespace.
   *
   * Format: tenants/{tenant}
   */
  readonly parent: string;
  /** The namespace id. */
  readonly namespaceId: string;
  /** The namespace metadata. */
  readonly namespace: Namespace | undefined;
}

export interface GetNamespaceRequest {
  $type: "wings.v1.cluster_metadata.GetNamespaceRequest";
  /**
   * The namespace name.
   *
   * Format: tenants/{tenant}/namespaces/{namespace}
   */
  readonly name: string;
}

export interface ListNamespacesRequest {
  $type: "wings.v1.cluster_metadata.ListNamespacesRequest";
  /**
   * The parent tenant.
   *
   * Format: tenants/{tenant}
   */
  readonly parent: string;
  /**
   * The number of namespaces to return.
   *
   * Default: 100
   * Maximum: 1000.
   */
  readonly pageSize?:
    | number
    | undefined;
  /** The continuation token. */
  readonly pageToken?: string | undefined;
}

export interface ListNamespacesResponse {
  $type: "wings.v1.cluster_metadata.ListNamespacesResponse";
  /** The namespaces. */
  readonly namespaces: readonly Namespace[];
  /** The continuation token. */
  readonly nextPageToken: string;
}

export interface DeleteNamespaceRequest {
  $type: "wings.v1.cluster_metadata.DeleteNamespaceRequest";
  /**
   * The namespace name.
   *
   * Format: tenants/{tenant}/namespaces/{namespace}
   */
  readonly name: string;
}

export interface Namespace {
  $type: "wings.v1.cluster_metadata.Namespace";
  /**
   * The namespace name.
   *
   * Format: tenants/{tenant}/namespaces/{namespace}
   */
  readonly name: string;
  /** The size at which the current segment is flushed to object storage. */
  readonly flushSizeBytes: bigint;
  /** The maximum interval at which the current segment is flushed to object storage (in milliseconds). */
  readonly flushIntervalMillis: bigint;
  /** The default object store configuration for the namespace. */
  readonly defaultObjectStoreConfig: string;
  /** If specified, use this configuration for frozen data. */
  readonly frozenObjectStoreConfig?: string | undefined;
}

export interface CreateTopicRequest {
  $type: "wings.v1.cluster_metadata.CreateTopicRequest";
  /**
   * The namespace that owns the topic.
   *
   * Format: tenants/{tenant}/namespaces/{namespace}
   */
  readonly parent: string;
  /** The topic id. */
  readonly topicId: string;
  /** The topic metadata. */
  readonly topic: Topic | undefined;
}

export interface GetTopicRequest {
  $type: "wings.v1.cluster_metadata.GetTopicRequest";
  /**
   * The topic name.
   *
   * Format: tenants/{tenant}/namespaces/{namespace}/topics/{topic}
   */
  readonly name: string;
}

export interface ListTopicsRequest {
  $type: "wings.v1.cluster_metadata.ListTopicsRequest";
  /**
   * The parent namespace.
   *
   * Format: tenants/{tenant}/namespaces/{namespace}
   */
  readonly parent: string;
  /**
   * The number of topics to return.
   *
   * Default: 100
   * Maximum: 1000.
   */
  readonly pageSize?:
    | number
    | undefined;
  /** The continuation token. */
  readonly pageToken?: string | undefined;
}

export interface ListTopicsResponse {
  $type: "wings.v1.cluster_metadata.ListTopicsResponse";
  /** The topics. */
  readonly topics: readonly Topic[];
  /** The continuation token. */
  readonly nextPageToken: string;
}

export interface DeleteTopicRequest {
  $type: "wings.v1.cluster_metadata.DeleteTopicRequest";
  /**
   * The topic name.
   *
   * Format: tenants/{tenant}/namespaces/{namespace}/topics/{topic}
   */
  readonly name: string;
  /** If set to true, also delete data associated with the topic. */
  readonly force: boolean;
}

export interface Topic {
  $type: "wings.v1.cluster_metadata.Topic";
  /**
   * The topic name.
   *
   * Format: tenants/{tenant}/namespaces/{namespace}/topics/{topic}
   */
  readonly name: string;
  /** The fields in the topic messages. */
  readonly fields: Uint8Array;
  /** The index of the field that is used to partition the topic. */
  readonly partitionKey?: number | undefined;
}

function createBaseCreateTenantRequest(): CreateTenantRequest {
  return { $type: "wings.v1.cluster_metadata.CreateTenantRequest", tenantId: "", tenant: undefined };
}

export const CreateTenantRequest: MessageFns<CreateTenantRequest, "wings.v1.cluster_metadata.CreateTenantRequest"> = {
  $type: "wings.v1.cluster_metadata.CreateTenantRequest" as const,

  encode(message: CreateTenantRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tenantId !== "") {
      writer.uint32(10).string(message.tenantId);
    }
    if (message.tenant !== undefined) {
      Tenant.encode(message.tenant, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTenantRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTenantRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tenantId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tenant = Tenant.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTenantRequest {
    return {
      $type: CreateTenantRequest.$type,
      tenantId: isSet(object.tenantId) ? globalThis.String(object.tenantId) : "",
      tenant: isSet(object.tenant) ? Tenant.fromJSON(object.tenant) : undefined,
    };
  },

  toJSON(message: CreateTenantRequest): unknown {
    const obj: any = {};
    if (message.tenantId !== "") {
      obj.tenantId = message.tenantId;
    }
    if (message.tenant !== undefined) {
      obj.tenant = Tenant.toJSON(message.tenant);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateTenantRequest>, I>>(base?: I): CreateTenantRequest {
    return CreateTenantRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateTenantRequest>, I>>(object: I): CreateTenantRequest {
    const message = createBaseCreateTenantRequest() as any;
    message.tenantId = object.tenantId ?? "";
    message.tenant = (object.tenant !== undefined && object.tenant !== null)
      ? Tenant.fromPartial(object.tenant)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(CreateTenantRequest.$type, CreateTenantRequest);

function createBaseGetTenantRequest(): GetTenantRequest {
  return { $type: "wings.v1.cluster_metadata.GetTenantRequest", name: "" };
}

export const GetTenantRequest: MessageFns<GetTenantRequest, "wings.v1.cluster_metadata.GetTenantRequest"> = {
  $type: "wings.v1.cluster_metadata.GetTenantRequest" as const,

  encode(message: GetTenantRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTenantRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTenantRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTenantRequest {
    return { $type: GetTenantRequest.$type, name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetTenantRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTenantRequest>, I>>(base?: I): GetTenantRequest {
    return GetTenantRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTenantRequest>, I>>(object: I): GetTenantRequest {
    const message = createBaseGetTenantRequest() as any;
    message.name = object.name ?? "";
    return message;
  },
};

messageTypeRegistry.set(GetTenantRequest.$type, GetTenantRequest);

function createBaseListTenantsRequest(): ListTenantsRequest {
  return { $type: "wings.v1.cluster_metadata.ListTenantsRequest", pageSize: undefined, pageToken: undefined };
}

export const ListTenantsRequest: MessageFns<ListTenantsRequest, "wings.v1.cluster_metadata.ListTenantsRequest"> = {
  $type: "wings.v1.cluster_metadata.ListTenantsRequest" as const,

  encode(message: ListTenantsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== undefined) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      writer.uint32(18).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTenantsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTenantsRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTenantsRequest {
    return {
      $type: ListTenantsRequest.$type,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : undefined,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : undefined,
    };
  },

  toJSON(message: ListTenantsRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTenantsRequest>, I>>(base?: I): ListTenantsRequest {
    return ListTenantsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTenantsRequest>, I>>(object: I): ListTenantsRequest {
    const message = createBaseListTenantsRequest() as any;
    message.pageSize = object.pageSize ?? undefined;
    message.pageToken = object.pageToken ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ListTenantsRequest.$type, ListTenantsRequest);

function createBaseListTenantsResponse(): ListTenantsResponse {
  return { $type: "wings.v1.cluster_metadata.ListTenantsResponse", tenants: [], nextPageToken: "" };
}

export const ListTenantsResponse: MessageFns<ListTenantsResponse, "wings.v1.cluster_metadata.ListTenantsResponse"> = {
  $type: "wings.v1.cluster_metadata.ListTenantsResponse" as const,

  encode(message: ListTenantsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tenants) {
      Tenant.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTenantsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTenantsResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tenants.push(Tenant.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTenantsResponse {
    return {
      $type: ListTenantsResponse.$type,
      tenants: globalThis.Array.isArray(object?.tenants) ? object.tenants.map((e: any) => Tenant.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListTenantsResponse): unknown {
    const obj: any = {};
    if (message.tenants?.length) {
      obj.tenants = message.tenants.map((e) => Tenant.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTenantsResponse>, I>>(base?: I): ListTenantsResponse {
    return ListTenantsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTenantsResponse>, I>>(object: I): ListTenantsResponse {
    const message = createBaseListTenantsResponse() as any;
    message.tenants = object.tenants?.map((e) => Tenant.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

messageTypeRegistry.set(ListTenantsResponse.$type, ListTenantsResponse);

function createBaseDeleteTenantRequest(): DeleteTenantRequest {
  return { $type: "wings.v1.cluster_metadata.DeleteTenantRequest", name: "" };
}

export const DeleteTenantRequest: MessageFns<DeleteTenantRequest, "wings.v1.cluster_metadata.DeleteTenantRequest"> = {
  $type: "wings.v1.cluster_metadata.DeleteTenantRequest" as const,

  encode(message: DeleteTenantRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTenantRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTenantRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTenantRequest {
    return { $type: DeleteTenantRequest.$type, name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteTenantRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteTenantRequest>, I>>(base?: I): DeleteTenantRequest {
    return DeleteTenantRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteTenantRequest>, I>>(object: I): DeleteTenantRequest {
    const message = createBaseDeleteTenantRequest() as any;
    message.name = object.name ?? "";
    return message;
  },
};

messageTypeRegistry.set(DeleteTenantRequest.$type, DeleteTenantRequest);

function createBaseTenant(): Tenant {
  return { $type: "wings.v1.cluster_metadata.Tenant", name: "" };
}

export const Tenant: MessageFns<Tenant, "wings.v1.cluster_metadata.Tenant"> = {
  $type: "wings.v1.cluster_metadata.Tenant" as const,

  encode(message: Tenant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tenant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTenant() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tenant {
    return { $type: Tenant.$type, name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: Tenant): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Tenant>, I>>(base?: I): Tenant {
    return Tenant.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Tenant>, I>>(object: I): Tenant {
    const message = createBaseTenant() as any;
    message.name = object.name ?? "";
    return message;
  },
};

messageTypeRegistry.set(Tenant.$type, Tenant);

function createBaseCreateNamespaceRequest(): CreateNamespaceRequest {
  return {
    $type: "wings.v1.cluster_metadata.CreateNamespaceRequest",
    parent: "",
    namespaceId: "",
    namespace: undefined,
  };
}

export const CreateNamespaceRequest: MessageFns<
  CreateNamespaceRequest,
  "wings.v1.cluster_metadata.CreateNamespaceRequest"
> = {
  $type: "wings.v1.cluster_metadata.CreateNamespaceRequest" as const,

  encode(message: CreateNamespaceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.namespaceId !== "") {
      writer.uint32(18).string(message.namespaceId);
    }
    if (message.namespace !== undefined) {
      Namespace.encode(message.namespace, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateNamespaceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateNamespaceRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.namespaceId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.namespace = Namespace.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateNamespaceRequest {
    return {
      $type: CreateNamespaceRequest.$type,
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      namespaceId: isSet(object.namespaceId) ? globalThis.String(object.namespaceId) : "",
      namespace: isSet(object.namespace) ? Namespace.fromJSON(object.namespace) : undefined,
    };
  },

  toJSON(message: CreateNamespaceRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.namespaceId !== "") {
      obj.namespaceId = message.namespaceId;
    }
    if (message.namespace !== undefined) {
      obj.namespace = Namespace.toJSON(message.namespace);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateNamespaceRequest>, I>>(base?: I): CreateNamespaceRequest {
    return CreateNamespaceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateNamespaceRequest>, I>>(object: I): CreateNamespaceRequest {
    const message = createBaseCreateNamespaceRequest() as any;
    message.parent = object.parent ?? "";
    message.namespaceId = object.namespaceId ?? "";
    message.namespace = (object.namespace !== undefined && object.namespace !== null)
      ? Namespace.fromPartial(object.namespace)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(CreateNamespaceRequest.$type, CreateNamespaceRequest);

function createBaseGetNamespaceRequest(): GetNamespaceRequest {
  return { $type: "wings.v1.cluster_metadata.GetNamespaceRequest", name: "" };
}

export const GetNamespaceRequest: MessageFns<GetNamespaceRequest, "wings.v1.cluster_metadata.GetNamespaceRequest"> = {
  $type: "wings.v1.cluster_metadata.GetNamespaceRequest" as const,

  encode(message: GetNamespaceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNamespaceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNamespaceRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNamespaceRequest {
    return { $type: GetNamespaceRequest.$type, name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetNamespaceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNamespaceRequest>, I>>(base?: I): GetNamespaceRequest {
    return GetNamespaceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNamespaceRequest>, I>>(object: I): GetNamespaceRequest {
    const message = createBaseGetNamespaceRequest() as any;
    message.name = object.name ?? "";
    return message;
  },
};

messageTypeRegistry.set(GetNamespaceRequest.$type, GetNamespaceRequest);

function createBaseListNamespacesRequest(): ListNamespacesRequest {
  return {
    $type: "wings.v1.cluster_metadata.ListNamespacesRequest",
    parent: "",
    pageSize: undefined,
    pageToken: undefined,
  };
}

export const ListNamespacesRequest: MessageFns<
  ListNamespacesRequest,
  "wings.v1.cluster_metadata.ListNamespacesRequest"
> = {
  $type: "wings.v1.cluster_metadata.ListNamespacesRequest" as const,

  encode(message: ListNamespacesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== undefined) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNamespacesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNamespacesRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNamespacesRequest {
    return {
      $type: ListNamespacesRequest.$type,
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : undefined,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : undefined,
    };
  },

  toJSON(message: ListNamespacesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListNamespacesRequest>, I>>(base?: I): ListNamespacesRequest {
    return ListNamespacesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListNamespacesRequest>, I>>(object: I): ListNamespacesRequest {
    const message = createBaseListNamespacesRequest() as any;
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? undefined;
    message.pageToken = object.pageToken ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ListNamespacesRequest.$type, ListNamespacesRequest);

function createBaseListNamespacesResponse(): ListNamespacesResponse {
  return { $type: "wings.v1.cluster_metadata.ListNamespacesResponse", namespaces: [], nextPageToken: "" };
}

export const ListNamespacesResponse: MessageFns<
  ListNamespacesResponse,
  "wings.v1.cluster_metadata.ListNamespacesResponse"
> = {
  $type: "wings.v1.cluster_metadata.ListNamespacesResponse" as const,

  encode(message: ListNamespacesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.namespaces) {
      Namespace.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNamespacesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNamespacesResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.namespaces.push(Namespace.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNamespacesResponse {
    return {
      $type: ListNamespacesResponse.$type,
      namespaces: globalThis.Array.isArray(object?.namespaces)
        ? object.namespaces.map((e: any) => Namespace.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListNamespacesResponse): unknown {
    const obj: any = {};
    if (message.namespaces?.length) {
      obj.namespaces = message.namespaces.map((e) => Namespace.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListNamespacesResponse>, I>>(base?: I): ListNamespacesResponse {
    return ListNamespacesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListNamespacesResponse>, I>>(object: I): ListNamespacesResponse {
    const message = createBaseListNamespacesResponse() as any;
    message.namespaces = object.namespaces?.map((e) => Namespace.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

messageTypeRegistry.set(ListNamespacesResponse.$type, ListNamespacesResponse);

function createBaseDeleteNamespaceRequest(): DeleteNamespaceRequest {
  return { $type: "wings.v1.cluster_metadata.DeleteNamespaceRequest", name: "" };
}

export const DeleteNamespaceRequest: MessageFns<
  DeleteNamespaceRequest,
  "wings.v1.cluster_metadata.DeleteNamespaceRequest"
> = {
  $type: "wings.v1.cluster_metadata.DeleteNamespaceRequest" as const,

  encode(message: DeleteNamespaceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteNamespaceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteNamespaceRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteNamespaceRequest {
    return { $type: DeleteNamespaceRequest.$type, name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteNamespaceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteNamespaceRequest>, I>>(base?: I): DeleteNamespaceRequest {
    return DeleteNamespaceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteNamespaceRequest>, I>>(object: I): DeleteNamespaceRequest {
    const message = createBaseDeleteNamespaceRequest() as any;
    message.name = object.name ?? "";
    return message;
  },
};

messageTypeRegistry.set(DeleteNamespaceRequest.$type, DeleteNamespaceRequest);

function createBaseNamespace(): Namespace {
  return {
    $type: "wings.v1.cluster_metadata.Namespace",
    name: "",
    flushSizeBytes: 0n,
    flushIntervalMillis: 0n,
    defaultObjectStoreConfig: "",
    frozenObjectStoreConfig: undefined,
  };
}

export const Namespace: MessageFns<Namespace, "wings.v1.cluster_metadata.Namespace"> = {
  $type: "wings.v1.cluster_metadata.Namespace" as const,

  encode(message: Namespace, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.flushSizeBytes !== 0n) {
      if (BigInt.asUintN(64, message.flushSizeBytes) !== message.flushSizeBytes) {
        throw new globalThis.Error("value provided for field message.flushSizeBytes of type uint64 too large");
      }
      writer.uint32(16).uint64(message.flushSizeBytes);
    }
    if (message.flushIntervalMillis !== 0n) {
      if (BigInt.asUintN(64, message.flushIntervalMillis) !== message.flushIntervalMillis) {
        throw new globalThis.Error("value provided for field message.flushIntervalMillis of type uint64 too large");
      }
      writer.uint32(24).uint64(message.flushIntervalMillis);
    }
    if (message.defaultObjectStoreConfig !== "") {
      writer.uint32(34).string(message.defaultObjectStoreConfig);
    }
    if (message.frozenObjectStoreConfig !== undefined) {
      writer.uint32(42).string(message.frozenObjectStoreConfig);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Namespace {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamespace() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.flushSizeBytes = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.flushIntervalMillis = reader.uint64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.defaultObjectStoreConfig = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.frozenObjectStoreConfig = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Namespace {
    return {
      $type: Namespace.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      flushSizeBytes: isSet(object.flushSizeBytes) ? BigInt(object.flushSizeBytes) : 0n,
      flushIntervalMillis: isSet(object.flushIntervalMillis) ? BigInt(object.flushIntervalMillis) : 0n,
      defaultObjectStoreConfig: isSet(object.defaultObjectStoreConfig)
        ? globalThis.String(object.defaultObjectStoreConfig)
        : "",
      frozenObjectStoreConfig: isSet(object.frozenObjectStoreConfig)
        ? globalThis.String(object.frozenObjectStoreConfig)
        : undefined,
    };
  },

  toJSON(message: Namespace): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.flushSizeBytes !== 0n) {
      obj.flushSizeBytes = message.flushSizeBytes.toString();
    }
    if (message.flushIntervalMillis !== 0n) {
      obj.flushIntervalMillis = message.flushIntervalMillis.toString();
    }
    if (message.defaultObjectStoreConfig !== "") {
      obj.defaultObjectStoreConfig = message.defaultObjectStoreConfig;
    }
    if (message.frozenObjectStoreConfig !== undefined) {
      obj.frozenObjectStoreConfig = message.frozenObjectStoreConfig;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Namespace>, I>>(base?: I): Namespace {
    return Namespace.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Namespace>, I>>(object: I): Namespace {
    const message = createBaseNamespace() as any;
    message.name = object.name ?? "";
    message.flushSizeBytes = object.flushSizeBytes ?? 0n;
    message.flushIntervalMillis = object.flushIntervalMillis ?? 0n;
    message.defaultObjectStoreConfig = object.defaultObjectStoreConfig ?? "";
    message.frozenObjectStoreConfig = object.frozenObjectStoreConfig ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Namespace.$type, Namespace);

function createBaseCreateTopicRequest(): CreateTopicRequest {
  return { $type: "wings.v1.cluster_metadata.CreateTopicRequest", parent: "", topicId: "", topic: undefined };
}

export const CreateTopicRequest: MessageFns<CreateTopicRequest, "wings.v1.cluster_metadata.CreateTopicRequest"> = {
  $type: "wings.v1.cluster_metadata.CreateTopicRequest" as const,

  encode(message: CreateTopicRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.topicId !== "") {
      writer.uint32(18).string(message.topicId);
    }
    if (message.topic !== undefined) {
      Topic.encode(message.topic, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTopicRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTopicRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.topicId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.topic = Topic.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTopicRequest {
    return {
      $type: CreateTopicRequest.$type,
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "",
      topic: isSet(object.topic) ? Topic.fromJSON(object.topic) : undefined,
    };
  },

  toJSON(message: CreateTopicRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.topicId !== "") {
      obj.topicId = message.topicId;
    }
    if (message.topic !== undefined) {
      obj.topic = Topic.toJSON(message.topic);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateTopicRequest>, I>>(base?: I): CreateTopicRequest {
    return CreateTopicRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateTopicRequest>, I>>(object: I): CreateTopicRequest {
    const message = createBaseCreateTopicRequest() as any;
    message.parent = object.parent ?? "";
    message.topicId = object.topicId ?? "";
    message.topic = (object.topic !== undefined && object.topic !== null) ? Topic.fromPartial(object.topic) : undefined;
    return message;
  },
};

messageTypeRegistry.set(CreateTopicRequest.$type, CreateTopicRequest);

function createBaseGetTopicRequest(): GetTopicRequest {
  return { $type: "wings.v1.cluster_metadata.GetTopicRequest", name: "" };
}

export const GetTopicRequest: MessageFns<GetTopicRequest, "wings.v1.cluster_metadata.GetTopicRequest"> = {
  $type: "wings.v1.cluster_metadata.GetTopicRequest" as const,

  encode(message: GetTopicRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTopicRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTopicRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTopicRequest {
    return { $type: GetTopicRequest.$type, name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetTopicRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTopicRequest>, I>>(base?: I): GetTopicRequest {
    return GetTopicRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTopicRequest>, I>>(object: I): GetTopicRequest {
    const message = createBaseGetTopicRequest() as any;
    message.name = object.name ?? "";
    return message;
  },
};

messageTypeRegistry.set(GetTopicRequest.$type, GetTopicRequest);

function createBaseListTopicsRequest(): ListTopicsRequest {
  return {
    $type: "wings.v1.cluster_metadata.ListTopicsRequest",
    parent: "",
    pageSize: undefined,
    pageToken: undefined,
  };
}

export const ListTopicsRequest: MessageFns<ListTopicsRequest, "wings.v1.cluster_metadata.ListTopicsRequest"> = {
  $type: "wings.v1.cluster_metadata.ListTopicsRequest" as const,

  encode(message: ListTopicsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== undefined) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTopicsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTopicsRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTopicsRequest {
    return {
      $type: ListTopicsRequest.$type,
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : undefined,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : undefined,
    };
  },

  toJSON(message: ListTopicsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTopicsRequest>, I>>(base?: I): ListTopicsRequest {
    return ListTopicsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTopicsRequest>, I>>(object: I): ListTopicsRequest {
    const message = createBaseListTopicsRequest() as any;
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? undefined;
    message.pageToken = object.pageToken ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ListTopicsRequest.$type, ListTopicsRequest);

function createBaseListTopicsResponse(): ListTopicsResponse {
  return { $type: "wings.v1.cluster_metadata.ListTopicsResponse", topics: [], nextPageToken: "" };
}

export const ListTopicsResponse: MessageFns<ListTopicsResponse, "wings.v1.cluster_metadata.ListTopicsResponse"> = {
  $type: "wings.v1.cluster_metadata.ListTopicsResponse" as const,

  encode(message: ListTopicsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.topics) {
      Topic.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTopicsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTopicsResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.topics.push(Topic.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTopicsResponse {
    return {
      $type: ListTopicsResponse.$type,
      topics: globalThis.Array.isArray(object?.topics) ? object.topics.map((e: any) => Topic.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListTopicsResponse): unknown {
    const obj: any = {};
    if (message.topics?.length) {
      obj.topics = message.topics.map((e) => Topic.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTopicsResponse>, I>>(base?: I): ListTopicsResponse {
    return ListTopicsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTopicsResponse>, I>>(object: I): ListTopicsResponse {
    const message = createBaseListTopicsResponse() as any;
    message.topics = object.topics?.map((e) => Topic.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

messageTypeRegistry.set(ListTopicsResponse.$type, ListTopicsResponse);

function createBaseDeleteTopicRequest(): DeleteTopicRequest {
  return { $type: "wings.v1.cluster_metadata.DeleteTopicRequest", name: "", force: false };
}

export const DeleteTopicRequest: MessageFns<DeleteTopicRequest, "wings.v1.cluster_metadata.DeleteTopicRequest"> = {
  $type: "wings.v1.cluster_metadata.DeleteTopicRequest" as const,

  encode(message: DeleteTopicRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.force !== false) {
      writer.uint32(16).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTopicRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTopicRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.force = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTopicRequest {
    return {
      $type: DeleteTopicRequest.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: DeleteTopicRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteTopicRequest>, I>>(base?: I): DeleteTopicRequest {
    return DeleteTopicRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteTopicRequest>, I>>(object: I): DeleteTopicRequest {
    const message = createBaseDeleteTopicRequest() as any;
    message.name = object.name ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

messageTypeRegistry.set(DeleteTopicRequest.$type, DeleteTopicRequest);

function createBaseTopic(): Topic {
  return { $type: "wings.v1.cluster_metadata.Topic", name: "", fields: new Uint8Array(0), partitionKey: undefined };
}

export const Topic: MessageFns<Topic, "wings.v1.cluster_metadata.Topic"> = {
  $type: "wings.v1.cluster_metadata.Topic" as const,

  encode(message: Topic, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.fields.length !== 0) {
      writer.uint32(18).bytes(message.fields);
    }
    if (message.partitionKey !== undefined) {
      writer.uint32(24).uint32(message.partitionKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Topic {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopic() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fields = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.partitionKey = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Topic {
    return {
      $type: Topic.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      fields: isSet(object.fields) ? bytesFromBase64(object.fields) : new Uint8Array(0),
      partitionKey: isSet(object.partitionKey) ? globalThis.Number(object.partitionKey) : undefined,
    };
  },

  toJSON(message: Topic): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.fields.length !== 0) {
      obj.fields = base64FromBytes(message.fields);
    }
    if (message.partitionKey !== undefined) {
      obj.partitionKey = Math.round(message.partitionKey);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Topic>, I>>(base?: I): Topic {
    return Topic.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Topic>, I>>(object: I): Topic {
    const message = createBaseTopic() as any;
    message.name = object.name ?? "";
    message.fields = object.fields ?? new Uint8Array(0);
    message.partitionKey = object.partitionKey ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(Topic.$type, Topic);

/** Cluster metadata service to manage cluster resources. */
export type ClusterMetadataServiceDefinition = typeof ClusterMetadataServiceDefinition;
export const ClusterMetadataServiceDefinition = {
  name: "ClusterMetadataService",
  fullName: "wings.v1.cluster_metadata.ClusterMetadataService",
  methods: {
    /** Create a new tenant. */
    createTenant: {
      name: "CreateTenant",
      requestType: CreateTenantRequest,
      requestStream: false,
      responseType: Tenant,
      responseStream: false,
      options: {},
    },
    /** Return the specified tenant. */
    getTenant: {
      name: "GetTenant",
      requestType: GetTenantRequest,
      requestStream: false,
      responseType: Tenant,
      responseStream: false,
      options: {},
    },
    /** List all tenants. */
    listTenants: {
      name: "ListTenants",
      requestType: ListTenantsRequest,
      requestStream: false,
      responseType: ListTenantsResponse,
      responseStream: false,
      options: {},
    },
    /**
     * Delete a tenant.
     *
     * The request fails if the tenant has any namespace.
     */
    deleteTenant: {
      name: "DeleteTenant",
      requestType: DeleteTenantRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Create a new namespace belonging to a tenant. */
    createNamespace: {
      name: "CreateNamespace",
      requestType: CreateNamespaceRequest,
      requestStream: false,
      responseType: Namespace,
      responseStream: false,
      options: {},
    },
    /** Return the specified namespace. */
    getNamespace: {
      name: "GetNamespace",
      requestType: GetNamespaceRequest,
      requestStream: false,
      responseType: Namespace,
      responseStream: false,
      options: {},
    },
    /** List all namespaces belonging to a tenant. */
    listNamespaces: {
      name: "ListNamespaces",
      requestType: ListNamespacesRequest,
      requestStream: false,
      responseType: ListNamespacesResponse,
      responseStream: false,
      options: {},
    },
    /**
     * Delete a namespace.
     *
     * The request fails if the namespace has any topic.
     */
    deleteNamespace: {
      name: "DeleteNamespace",
      requestType: DeleteNamespaceRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Create a new topic belonging to a namespace. */
    createTopic: {
      name: "CreateTopic",
      requestType: CreateTopicRequest,
      requestStream: false,
      responseType: Topic,
      responseStream: false,
      options: {},
    },
    /** Return the specified topic. */
    getTopic: {
      name: "GetTopic",
      requestType: GetTopicRequest,
      requestStream: false,
      responseType: Topic,
      responseStream: false,
      options: {},
    },
    /** List all topics belonging to a namespace. */
    listTopics: {
      name: "ListTopics",
      requestType: ListTopicsRequest,
      requestStream: false,
      responseType: ListTopicsResponse,
      responseStream: false,
      options: {},
    },
    /** Delete a topic. */
    deleteTopic: {
      name: "DeleteTopic",
      requestType: DeleteTopicRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface ClusterMetadataServiceImplementation<CallContextExt = {}> {
  /** Create a new tenant. */
  createTenant(request: CreateTenantRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Tenant>>;
  /** Return the specified tenant. */
  getTenant(request: GetTenantRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Tenant>>;
  /** List all tenants. */
  listTenants(
    request: ListTenantsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListTenantsResponse>>;
  /**
   * Delete a tenant.
   *
   * The request fails if the tenant has any namespace.
   */
  deleteTenant(request: DeleteTenantRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Create a new namespace belonging to a tenant. */
  createNamespace(
    request: CreateNamespaceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Namespace>>;
  /** Return the specified namespace. */
  getNamespace(request: GetNamespaceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Namespace>>;
  /** List all namespaces belonging to a tenant. */
  listNamespaces(
    request: ListNamespacesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListNamespacesResponse>>;
  /**
   * Delete a namespace.
   *
   * The request fails if the namespace has any topic.
   */
  deleteNamespace(request: DeleteNamespaceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Create a new topic belonging to a namespace. */
  createTopic(request: CreateTopicRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Topic>>;
  /** Return the specified topic. */
  getTopic(request: GetTopicRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Topic>>;
  /** List all topics belonging to a namespace. */
  listTopics(
    request: ListTopicsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListTopicsResponse>>;
  /** Delete a topic. */
  deleteTopic(request: DeleteTopicRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
}

export interface ClusterMetadataServiceClient<CallOptionsExt = {}> {
  /** Create a new tenant. */
  createTenant(request: DeepPartial<CreateTenantRequest>, options?: CallOptions & CallOptionsExt): Promise<Tenant>;
  /** Return the specified tenant. */
  getTenant(request: DeepPartial<GetTenantRequest>, options?: CallOptions & CallOptionsExt): Promise<Tenant>;
  /** List all tenants. */
  listTenants(
    request: DeepPartial<ListTenantsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListTenantsResponse>;
  /**
   * Delete a tenant.
   *
   * The request fails if the tenant has any namespace.
   */
  deleteTenant(request: DeepPartial<DeleteTenantRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Create a new namespace belonging to a tenant. */
  createNamespace(
    request: DeepPartial<CreateNamespaceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Namespace>;
  /** Return the specified namespace. */
  getNamespace(request: DeepPartial<GetNamespaceRequest>, options?: CallOptions & CallOptionsExt): Promise<Namespace>;
  /** List all namespaces belonging to a tenant. */
  listNamespaces(
    request: DeepPartial<ListNamespacesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListNamespacesResponse>;
  /**
   * Delete a namespace.
   *
   * The request fails if the namespace has any topic.
   */
  deleteNamespace(request: DeepPartial<DeleteNamespaceRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Create a new topic belonging to a namespace. */
  createTopic(request: DeepPartial<CreateTopicRequest>, options?: CallOptions & CallOptionsExt): Promise<Topic>;
  /** Return the specified topic. */
  getTopic(request: DeepPartial<GetTopicRequest>, options?: CallOptions & CallOptionsExt): Promise<Topic>;
  /** List all topics belonging to a namespace. */
  listTopics(
    request: DeepPartial<ListTopicsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListTopicsResponse>;
  /** Delete a topic. */
  deleteTopic(request: DeepPartial<DeleteTopicRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { readonly $case: string }
    ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { readonly $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
