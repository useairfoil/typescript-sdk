// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: cluster_metadata.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { Empty } from "./google/protobuf/empty.js";
import { messageTypeRegistry } from "./typeRegistry.js";

export const protobufPackage = "wings.v1.cluster_metadata";

export interface CreateTenantRequest {
  $type: "wings.v1.cluster_metadata.CreateTenantRequest";
  /** The tenant id. */
  readonly tenantId: string;
  /** The tenant metadata. */
  readonly tenant: Tenant | undefined;
}

export interface GetTenantRequest {
  $type: "wings.v1.cluster_metadata.GetTenantRequest";
  /**
   * The tenant name.
   *
   * Format: tenants/{tenant}
   */
  readonly name: string;
}

export interface ListTenantsRequest {
  $type: "wings.v1.cluster_metadata.ListTenantsRequest";
  /**
   * The number of tenants to return.
   *
   * Default: 100
   * Maximum: 1000.
   */
  readonly pageSize?:
    | number
    | undefined;
  /** The continuation token. */
  readonly pageToken?: string | undefined;
}

export interface ListTenantsResponse {
  $type: "wings.v1.cluster_metadata.ListTenantsResponse";
  /** The tenants. */
  readonly tenants: readonly Tenant[];
  /** The continuation token. */
  readonly nextPageToken: string;
}

export interface DeleteTenantRequest {
  $type: "wings.v1.cluster_metadata.DeleteTenantRequest";
  /**
   * The tenant name.
   *
   * Format: tenants/{tenant}
   */
  readonly name: string;
}

export interface Tenant {
  $type: "wings.v1.cluster_metadata.Tenant";
  /**
   * The tenant name.
   *
   * Format: tenants/{tenant}
   */
  readonly name: string;
}

export interface CreateNamespaceRequest {
  $type: "wings.v1.cluster_metadata.CreateNamespaceRequest";
  /**
   * The tenant that owns the namespace.
   *
   * Format: tenants/{tenant}
   */
  readonly parent: string;
  /** The namespace id. */
  readonly namespaceId: string;
  /** The namespace metadata. */
  readonly namespace: Namespace | undefined;
}

export interface GetNamespaceRequest {
  $type: "wings.v1.cluster_metadata.GetNamespaceRequest";
  /**
   * The namespace name.
   *
   * Format: tenants/{tenant}/namespaces/{namespace}
   */
  readonly name: string;
}

export interface ListNamespacesRequest {
  $type: "wings.v1.cluster_metadata.ListNamespacesRequest";
  /**
   * The parent tenant.
   *
   * Format: tenants/{tenant}
   */
  readonly parent: string;
  /**
   * The number of namespaces to return.
   *
   * Default: 100
   * Maximum: 1000.
   */
  readonly pageSize?:
    | number
    | undefined;
  /** The continuation token. */
  readonly pageToken?: string | undefined;
}

export interface ListNamespacesResponse {
  $type: "wings.v1.cluster_metadata.ListNamespacesResponse";
  /** The namespaces. */
  readonly namespaces: readonly Namespace[];
  /** The continuation token. */
  readonly nextPageToken: string;
}

export interface DeleteNamespaceRequest {
  $type: "wings.v1.cluster_metadata.DeleteNamespaceRequest";
  /**
   * The namespace name.
   *
   * Format: tenants/{tenant}/namespaces/{namespace}
   */
  readonly name: string;
}

export interface Namespace {
  $type: "wings.v1.cluster_metadata.Namespace";
  /**
   * The namespace name.
   *
   * Format: tenants/{tenant}/namespaces/{namespace}
   */
  readonly name: string;
  /** The size at which the current segment is flushed to object storage. */
  readonly flushSizeBytes: bigint;
  /** The maximum interval at which the current segment is flushed to object storage (in milliseconds). */
  readonly flushIntervalMillis: bigint;
  /** The object store used by this namespace. */
  readonly objectStore: string;
  /** The data lake used by this namespace. */
  readonly dataLake: string;
}

export interface CreateTopicRequest {
  $type: "wings.v1.cluster_metadata.CreateTopicRequest";
  /**
   * The namespace that owns the topic.
   *
   * Format: tenants/{tenant}/namespaces/{namespace}
   */
  readonly parent: string;
  /** The topic id. */
  readonly topicId: string;
  /** The topic metadata. */
  readonly topic: Topic | undefined;
}

export interface GetTopicRequest {
  $type: "wings.v1.cluster_metadata.GetTopicRequest";
  /**
   * The topic name.
   *
   * Format: tenants/{tenant}/namespaces/{namespace}/topics/{topic}
   */
  readonly name: string;
}

export interface ListTopicsRequest {
  $type: "wings.v1.cluster_metadata.ListTopicsRequest";
  /**
   * The parent namespace.
   *
   * Format: tenants/{tenant}/namespaces/{namespace}
   */
  readonly parent: string;
  /**
   * The number of topics to return.
   *
   * Default: 100
   * Maximum: 1000.
   */
  readonly pageSize?:
    | number
    | undefined;
  /** The continuation token. */
  readonly pageToken?: string | undefined;
}

export interface ListTopicsResponse {
  $type: "wings.v1.cluster_metadata.ListTopicsResponse";
  /** The topics. */
  readonly topics: readonly Topic[];
  /** The continuation token. */
  readonly nextPageToken: string;
}

export interface DeleteTopicRequest {
  $type: "wings.v1.cluster_metadata.DeleteTopicRequest";
  /**
   * The topic name.
   *
   * Format: tenants/{tenant}/namespaces/{namespace}/topics/{topic}
   */
  readonly name: string;
  /** If set to true, also delete data associated with the topic. */
  readonly force: boolean;
}

export interface Topic {
  $type: "wings.v1.cluster_metadata.Topic";
  /**
   * The topic name.
   *
   * Format: tenants/{tenant}/namespaces/{namespace}/topics/{topic}
   */
  readonly name: string;
  /** The fields in the topic messages. */
  readonly fields: Uint8Array;
  /** The topic description. */
  readonly description?:
    | string
    | undefined;
  /** The index of the field that is used to partition the topic. */
  readonly partitionKey?:
    | number
    | undefined;
  /** The topic compaction configuration. */
  readonly compaction: CompactionConfiguration | undefined;
}

export interface CompactionConfiguration {
  $type: "wings.v1.cluster_metadata.CompactionConfiguration";
  /** How often to compact the topic, in seconds. */
  readonly freshnessSeconds: bigint;
  /** How long to keep the topic data, in seconds. */
  readonly ttlSeconds?: bigint | undefined;
}

export interface CreateObjectStoreRequest {
  $type: "wings.v1.cluster_metadata.CreateObjectStoreRequest";
  /**
   * The tenant that owns the object store.
   *
   * Format: tenants/{tenant}
   */
  readonly parent: string;
  /** The object store id. */
  readonly objectStoreId: string;
  /** The object store metadata. */
  readonly objectStore: ObjectStore | undefined;
}

export interface GetObjectStoreRequest {
  $type: "wings.v1.cluster_metadata.GetObjectStoreRequest";
  /**
   * The object store name.
   *
   * Format: tenants/{tenant}/object-stores/{object-store}
   */
  readonly name: string;
}

export interface ListObjectStoresRequest {
  $type: "wings.v1.cluster_metadata.ListObjectStoresRequest";
  /**
   * The parent tenant.
   *
   * Format: tenants/{tenant}
   */
  readonly parent: string;
  /**
   * The number of object stores to return.
   *
   * Default: 100
   * Maximum: 1000.
   */
  readonly pageSize?:
    | number
    | undefined;
  /** The continuation token. */
  readonly pageToken?: string | undefined;
}

export interface ListObjectStoresResponse {
  $type: "wings.v1.cluster_metadata.ListObjectStoresResponse";
  /** The object stores. */
  readonly objectStores: readonly ObjectStore[];
  /** The continuation token. */
  readonly nextPageToken: string;
}

export interface DeleteObjectStoreRequest {
  $type: "wings.v1.cluster_metadata.DeleteObjectStoreRequest";
  /**
   * The object store name.
   *
   * Format: tenants/{tenant}/object-stores/{object-store}
   */
  readonly name: string;
}

export interface ObjectStore {
  $type: "wings.v1.cluster_metadata.ObjectStore";
  /**
   * The object store name.
   *
   * Format: tenants/{tenant}/object-stores/{object-store}
   */
  readonly name: string;
  /** Object store configuration. */
  readonly objectStoreConfig?:
    | { readonly $case: "aws"; readonly aws: AwsConfiguration }
    | { readonly $case: "azure"; readonly azure: AzureConfiguration }
    | { readonly $case: "google"; readonly google: GoogleConfiguration }
    | { readonly $case: "s3Compatible"; readonly s3Compatible: S3CompatibleConfiguration }
    | undefined;
}

export interface AwsConfiguration {
  $type: "wings.v1.cluster_metadata.AwsConfiguration";
  /** Bucket name. */
  readonly bucketName: string;
  /** Bucket prefix. */
  readonly prefix?:
    | string
    | undefined;
  /** / `AWS_ACCESS_KEY_ID` */
  readonly accessKeyId: string;
  /** / `AWS_SECRET_ACCESS_KEY` */
  readonly secretAccessKey: string;
  /** / `AWS_DEFAULT_REGION` */
  readonly region?: string | undefined;
}

export interface AzureConfiguration {
  $type: "wings.v1.cluster_metadata.AzureConfiguration";
  /** Azure container name. */
  readonly containerName: string;
  /** Container prefix. */
  readonly prefix?:
    | string
    | undefined;
  /** `AZURE_STORAGE_ACCOUNT_NAME` */
  readonly storageAccountName: string;
  /** `AZURE_STORAGE_ACCOUNT_KEY` */
  readonly storageAccountKey: string;
}

export interface GoogleConfiguration {
  $type: "wings.v1.cluster_metadata.GoogleConfiguration";
  /** / Bucket name. */
  readonly bucketName: string;
  /** / Bucket prefix. */
  readonly prefix?:
    | string
    | undefined;
  /** / `GOOGLE_SERVICE_ACCOUNT` */
  readonly serviceAccount: string;
  /** / `GOOGLE_SERVICE_ACCOUNT_KEY` */
  readonly serviceAccountKey: string;
}

export interface S3CompatibleConfiguration {
  $type: "wings.v1.cluster_metadata.S3CompatibleConfiguration";
  /** Bucket name. */
  readonly bucketName: string;
  /** Bucket prefix. */
  readonly prefix?:
    | string
    | undefined;
  /** / `AWS_ACCESS_KEY_ID` */
  readonly accessKeyId: string;
  /** / `AWS_SECRET_ACCESS_KEY` */
  readonly secretAccessKey: string;
  /** / `AWS_DEFAULT_REGION` */
  readonly region?:
    | string
    | undefined;
  /** / `AWS_ENDPOINT` */
  readonly endpoint: string;
}

export interface CreateDataLakeRequest {
  $type: "wings.v1.cluster_metadata.CreateDataLakeRequest";
  /**
   * The tenant that owns the data lake.
   *
   * Format: tenants/{tenant}
   */
  readonly parent: string;
  /** The data lake id. */
  readonly dataLakeId: string;
  /** The data lake metadata. */
  readonly dataLake: DataLake | undefined;
}

export interface GetDataLakeRequest {
  $type: "wings.v1.cluster_metadata.GetDataLakeRequest";
  /**
   * The data lake name.
   *
   * Format: tenants/{tenant}/data-lakes/{data-lake}
   */
  readonly name: string;
}

export interface ListDataLakesRequest {
  $type: "wings.v1.cluster_metadata.ListDataLakesRequest";
  /**
   * The parent tenant.
   *
   * Format: tenants/{tenant}
   */
  readonly parent: string;
  /**
   * The number of data lakes to return.
   *
   * Default: 100
   * Maximum: 1000.
   */
  readonly pageSize?:
    | number
    | undefined;
  /** The continuation token. */
  readonly pageToken?: string | undefined;
}

export interface ListDataLakesResponse {
  $type: "wings.v1.cluster_metadata.ListDataLakesResponse";
  /** The data lakes. */
  readonly dataLakes: readonly DataLake[];
  /** The continuation token. */
  readonly nextPageToken: string;
}

export interface DeleteDataLakeRequest {
  $type: "wings.v1.cluster_metadata.DeleteDataLakeRequest";
  /**
   * The data lake name.
   *
   * Format: tenants/{tenant}/data-lakes/{data-lake}
   */
  readonly name: string;
}

export interface DataLake {
  $type: "wings.v1.cluster_metadata.DataLake";
  /**
   * The data lake name.
   *
   * Format: tenants/{tenant}/data-lakes/{data-lake}
   */
  readonly name: string;
  /** Data lake configuration. */
  readonly dataLakeConfig?: { readonly $case: "iceberg"; readonly iceberg: IcebergConfiguration } | {
    readonly $case: "parquet";
    readonly parquet: ParquetConfiguration;
  } | undefined;
}

export interface IcebergConfiguration {
  $type: "wings.v1.cluster_metadata.IcebergConfiguration";
}

export interface ParquetConfiguration {
  $type: "wings.v1.cluster_metadata.ParquetConfiguration";
}

function createBaseCreateTenantRequest(): CreateTenantRequest {
  return { $type: "wings.v1.cluster_metadata.CreateTenantRequest", tenantId: "", tenant: undefined };
}

export const CreateTenantRequest: MessageFns<CreateTenantRequest, "wings.v1.cluster_metadata.CreateTenantRequest"> = {
  $type: "wings.v1.cluster_metadata.CreateTenantRequest" as const,

  encode(message: CreateTenantRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tenantId !== "") {
      writer.uint32(10).string(message.tenantId);
    }
    if (message.tenant !== undefined) {
      Tenant.encode(message.tenant, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTenantRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTenantRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tenantId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tenant = Tenant.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTenantRequest {
    return {
      $type: CreateTenantRequest.$type,
      tenantId: isSet(object.tenantId) ? globalThis.String(object.tenantId) : "",
      tenant: isSet(object.tenant) ? Tenant.fromJSON(object.tenant) : undefined,
    };
  },

  toJSON(message: CreateTenantRequest): unknown {
    const obj: any = {};
    if (message.tenantId !== "") {
      obj.tenantId = message.tenantId;
    }
    if (message.tenant !== undefined) {
      obj.tenant = Tenant.toJSON(message.tenant);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateTenantRequest>, I>>(base?: I): CreateTenantRequest {
    return CreateTenantRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateTenantRequest>, I>>(object: I): CreateTenantRequest {
    const message = createBaseCreateTenantRequest() as any;
    message.tenantId = object.tenantId ?? "";
    message.tenant = (object.tenant !== undefined && object.tenant !== null)
      ? Tenant.fromPartial(object.tenant)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(CreateTenantRequest.$type, CreateTenantRequest);

function createBaseGetTenantRequest(): GetTenantRequest {
  return { $type: "wings.v1.cluster_metadata.GetTenantRequest", name: "" };
}

export const GetTenantRequest: MessageFns<GetTenantRequest, "wings.v1.cluster_metadata.GetTenantRequest"> = {
  $type: "wings.v1.cluster_metadata.GetTenantRequest" as const,

  encode(message: GetTenantRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTenantRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTenantRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTenantRequest {
    return { $type: GetTenantRequest.$type, name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetTenantRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTenantRequest>, I>>(base?: I): GetTenantRequest {
    return GetTenantRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTenantRequest>, I>>(object: I): GetTenantRequest {
    const message = createBaseGetTenantRequest() as any;
    message.name = object.name ?? "";
    return message;
  },
};

messageTypeRegistry.set(GetTenantRequest.$type, GetTenantRequest);

function createBaseListTenantsRequest(): ListTenantsRequest {
  return { $type: "wings.v1.cluster_metadata.ListTenantsRequest", pageSize: undefined, pageToken: undefined };
}

export const ListTenantsRequest: MessageFns<ListTenantsRequest, "wings.v1.cluster_metadata.ListTenantsRequest"> = {
  $type: "wings.v1.cluster_metadata.ListTenantsRequest" as const,

  encode(message: ListTenantsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pageSize !== undefined) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      writer.uint32(18).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTenantsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTenantsRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTenantsRequest {
    return {
      $type: ListTenantsRequest.$type,
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : undefined,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : undefined,
    };
  },

  toJSON(message: ListTenantsRequest): unknown {
    const obj: any = {};
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTenantsRequest>, I>>(base?: I): ListTenantsRequest {
    return ListTenantsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTenantsRequest>, I>>(object: I): ListTenantsRequest {
    const message = createBaseListTenantsRequest() as any;
    message.pageSize = object.pageSize ?? undefined;
    message.pageToken = object.pageToken ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ListTenantsRequest.$type, ListTenantsRequest);

function createBaseListTenantsResponse(): ListTenantsResponse {
  return { $type: "wings.v1.cluster_metadata.ListTenantsResponse", tenants: [], nextPageToken: "" };
}

export const ListTenantsResponse: MessageFns<ListTenantsResponse, "wings.v1.cluster_metadata.ListTenantsResponse"> = {
  $type: "wings.v1.cluster_metadata.ListTenantsResponse" as const,

  encode(message: ListTenantsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tenants) {
      Tenant.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTenantsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTenantsResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tenants.push(Tenant.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTenantsResponse {
    return {
      $type: ListTenantsResponse.$type,
      tenants: globalThis.Array.isArray(object?.tenants) ? object.tenants.map((e: any) => Tenant.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListTenantsResponse): unknown {
    const obj: any = {};
    if (message.tenants?.length) {
      obj.tenants = message.tenants.map((e) => Tenant.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTenantsResponse>, I>>(base?: I): ListTenantsResponse {
    return ListTenantsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTenantsResponse>, I>>(object: I): ListTenantsResponse {
    const message = createBaseListTenantsResponse() as any;
    message.tenants = object.tenants?.map((e) => Tenant.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

messageTypeRegistry.set(ListTenantsResponse.$type, ListTenantsResponse);

function createBaseDeleteTenantRequest(): DeleteTenantRequest {
  return { $type: "wings.v1.cluster_metadata.DeleteTenantRequest", name: "" };
}

export const DeleteTenantRequest: MessageFns<DeleteTenantRequest, "wings.v1.cluster_metadata.DeleteTenantRequest"> = {
  $type: "wings.v1.cluster_metadata.DeleteTenantRequest" as const,

  encode(message: DeleteTenantRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTenantRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTenantRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTenantRequest {
    return { $type: DeleteTenantRequest.$type, name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteTenantRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteTenantRequest>, I>>(base?: I): DeleteTenantRequest {
    return DeleteTenantRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteTenantRequest>, I>>(object: I): DeleteTenantRequest {
    const message = createBaseDeleteTenantRequest() as any;
    message.name = object.name ?? "";
    return message;
  },
};

messageTypeRegistry.set(DeleteTenantRequest.$type, DeleteTenantRequest);

function createBaseTenant(): Tenant {
  return { $type: "wings.v1.cluster_metadata.Tenant", name: "" };
}

export const Tenant: MessageFns<Tenant, "wings.v1.cluster_metadata.Tenant"> = {
  $type: "wings.v1.cluster_metadata.Tenant" as const,

  encode(message: Tenant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tenant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTenant() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tenant {
    return { $type: Tenant.$type, name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: Tenant): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Tenant>, I>>(base?: I): Tenant {
    return Tenant.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Tenant>, I>>(object: I): Tenant {
    const message = createBaseTenant() as any;
    message.name = object.name ?? "";
    return message;
  },
};

messageTypeRegistry.set(Tenant.$type, Tenant);

function createBaseCreateNamespaceRequest(): CreateNamespaceRequest {
  return {
    $type: "wings.v1.cluster_metadata.CreateNamespaceRequest",
    parent: "",
    namespaceId: "",
    namespace: undefined,
  };
}

export const CreateNamespaceRequest: MessageFns<
  CreateNamespaceRequest,
  "wings.v1.cluster_metadata.CreateNamespaceRequest"
> = {
  $type: "wings.v1.cluster_metadata.CreateNamespaceRequest" as const,

  encode(message: CreateNamespaceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.namespaceId !== "") {
      writer.uint32(18).string(message.namespaceId);
    }
    if (message.namespace !== undefined) {
      Namespace.encode(message.namespace, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateNamespaceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateNamespaceRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.namespaceId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.namespace = Namespace.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateNamespaceRequest {
    return {
      $type: CreateNamespaceRequest.$type,
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      namespaceId: isSet(object.namespaceId) ? globalThis.String(object.namespaceId) : "",
      namespace: isSet(object.namespace) ? Namespace.fromJSON(object.namespace) : undefined,
    };
  },

  toJSON(message: CreateNamespaceRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.namespaceId !== "") {
      obj.namespaceId = message.namespaceId;
    }
    if (message.namespace !== undefined) {
      obj.namespace = Namespace.toJSON(message.namespace);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateNamespaceRequest>, I>>(base?: I): CreateNamespaceRequest {
    return CreateNamespaceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateNamespaceRequest>, I>>(object: I): CreateNamespaceRequest {
    const message = createBaseCreateNamespaceRequest() as any;
    message.parent = object.parent ?? "";
    message.namespaceId = object.namespaceId ?? "";
    message.namespace = (object.namespace !== undefined && object.namespace !== null)
      ? Namespace.fromPartial(object.namespace)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(CreateNamespaceRequest.$type, CreateNamespaceRequest);

function createBaseGetNamespaceRequest(): GetNamespaceRequest {
  return { $type: "wings.v1.cluster_metadata.GetNamespaceRequest", name: "" };
}

export const GetNamespaceRequest: MessageFns<GetNamespaceRequest, "wings.v1.cluster_metadata.GetNamespaceRequest"> = {
  $type: "wings.v1.cluster_metadata.GetNamespaceRequest" as const,

  encode(message: GetNamespaceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetNamespaceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetNamespaceRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetNamespaceRequest {
    return { $type: GetNamespaceRequest.$type, name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetNamespaceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetNamespaceRequest>, I>>(base?: I): GetNamespaceRequest {
    return GetNamespaceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetNamespaceRequest>, I>>(object: I): GetNamespaceRequest {
    const message = createBaseGetNamespaceRequest() as any;
    message.name = object.name ?? "";
    return message;
  },
};

messageTypeRegistry.set(GetNamespaceRequest.$type, GetNamespaceRequest);

function createBaseListNamespacesRequest(): ListNamespacesRequest {
  return {
    $type: "wings.v1.cluster_metadata.ListNamespacesRequest",
    parent: "",
    pageSize: undefined,
    pageToken: undefined,
  };
}

export const ListNamespacesRequest: MessageFns<
  ListNamespacesRequest,
  "wings.v1.cluster_metadata.ListNamespacesRequest"
> = {
  $type: "wings.v1.cluster_metadata.ListNamespacesRequest" as const,

  encode(message: ListNamespacesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== undefined) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNamespacesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNamespacesRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNamespacesRequest {
    return {
      $type: ListNamespacesRequest.$type,
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : undefined,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : undefined,
    };
  },

  toJSON(message: ListNamespacesRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListNamespacesRequest>, I>>(base?: I): ListNamespacesRequest {
    return ListNamespacesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListNamespacesRequest>, I>>(object: I): ListNamespacesRequest {
    const message = createBaseListNamespacesRequest() as any;
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? undefined;
    message.pageToken = object.pageToken ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ListNamespacesRequest.$type, ListNamespacesRequest);

function createBaseListNamespacesResponse(): ListNamespacesResponse {
  return { $type: "wings.v1.cluster_metadata.ListNamespacesResponse", namespaces: [], nextPageToken: "" };
}

export const ListNamespacesResponse: MessageFns<
  ListNamespacesResponse,
  "wings.v1.cluster_metadata.ListNamespacesResponse"
> = {
  $type: "wings.v1.cluster_metadata.ListNamespacesResponse" as const,

  encode(message: ListNamespacesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.namespaces) {
      Namespace.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListNamespacesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListNamespacesResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.namespaces.push(Namespace.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListNamespacesResponse {
    return {
      $type: ListNamespacesResponse.$type,
      namespaces: globalThis.Array.isArray(object?.namespaces)
        ? object.namespaces.map((e: any) => Namespace.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListNamespacesResponse): unknown {
    const obj: any = {};
    if (message.namespaces?.length) {
      obj.namespaces = message.namespaces.map((e) => Namespace.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListNamespacesResponse>, I>>(base?: I): ListNamespacesResponse {
    return ListNamespacesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListNamespacesResponse>, I>>(object: I): ListNamespacesResponse {
    const message = createBaseListNamespacesResponse() as any;
    message.namespaces = object.namespaces?.map((e) => Namespace.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

messageTypeRegistry.set(ListNamespacesResponse.$type, ListNamespacesResponse);

function createBaseDeleteNamespaceRequest(): DeleteNamespaceRequest {
  return { $type: "wings.v1.cluster_metadata.DeleteNamespaceRequest", name: "" };
}

export const DeleteNamespaceRequest: MessageFns<
  DeleteNamespaceRequest,
  "wings.v1.cluster_metadata.DeleteNamespaceRequest"
> = {
  $type: "wings.v1.cluster_metadata.DeleteNamespaceRequest" as const,

  encode(message: DeleteNamespaceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteNamespaceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteNamespaceRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteNamespaceRequest {
    return { $type: DeleteNamespaceRequest.$type, name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteNamespaceRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteNamespaceRequest>, I>>(base?: I): DeleteNamespaceRequest {
    return DeleteNamespaceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteNamespaceRequest>, I>>(object: I): DeleteNamespaceRequest {
    const message = createBaseDeleteNamespaceRequest() as any;
    message.name = object.name ?? "";
    return message;
  },
};

messageTypeRegistry.set(DeleteNamespaceRequest.$type, DeleteNamespaceRequest);

function createBaseNamespace(): Namespace {
  return {
    $type: "wings.v1.cluster_metadata.Namespace",
    name: "",
    flushSizeBytes: 0n,
    flushIntervalMillis: 0n,
    objectStore: "",
    dataLake: "",
  };
}

export const Namespace: MessageFns<Namespace, "wings.v1.cluster_metadata.Namespace"> = {
  $type: "wings.v1.cluster_metadata.Namespace" as const,

  encode(message: Namespace, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.flushSizeBytes !== 0n) {
      if (BigInt.asUintN(64, message.flushSizeBytes) !== message.flushSizeBytes) {
        throw new globalThis.Error("value provided for field message.flushSizeBytes of type uint64 too large");
      }
      writer.uint32(16).uint64(message.flushSizeBytes);
    }
    if (message.flushIntervalMillis !== 0n) {
      if (BigInt.asUintN(64, message.flushIntervalMillis) !== message.flushIntervalMillis) {
        throw new globalThis.Error("value provided for field message.flushIntervalMillis of type uint64 too large");
      }
      writer.uint32(24).uint64(message.flushIntervalMillis);
    }
    if (message.objectStore !== "") {
      writer.uint32(34).string(message.objectStore);
    }
    if (message.dataLake !== "") {
      writer.uint32(42).string(message.dataLake);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Namespace {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamespace() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.flushSizeBytes = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.flushIntervalMillis = reader.uint64() as bigint;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.objectStore = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.dataLake = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Namespace {
    return {
      $type: Namespace.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      flushSizeBytes: isSet(object.flushSizeBytes) ? BigInt(object.flushSizeBytes) : 0n,
      flushIntervalMillis: isSet(object.flushIntervalMillis) ? BigInt(object.flushIntervalMillis) : 0n,
      objectStore: isSet(object.objectStore) ? globalThis.String(object.objectStore) : "",
      dataLake: isSet(object.dataLake) ? globalThis.String(object.dataLake) : "",
    };
  },

  toJSON(message: Namespace): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.flushSizeBytes !== 0n) {
      obj.flushSizeBytes = message.flushSizeBytes.toString();
    }
    if (message.flushIntervalMillis !== 0n) {
      obj.flushIntervalMillis = message.flushIntervalMillis.toString();
    }
    if (message.objectStore !== "") {
      obj.objectStore = message.objectStore;
    }
    if (message.dataLake !== "") {
      obj.dataLake = message.dataLake;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Namespace>, I>>(base?: I): Namespace {
    return Namespace.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Namespace>, I>>(object: I): Namespace {
    const message = createBaseNamespace() as any;
    message.name = object.name ?? "";
    message.flushSizeBytes = object.flushSizeBytes ?? 0n;
    message.flushIntervalMillis = object.flushIntervalMillis ?? 0n;
    message.objectStore = object.objectStore ?? "";
    message.dataLake = object.dataLake ?? "";
    return message;
  },
};

messageTypeRegistry.set(Namespace.$type, Namespace);

function createBaseCreateTopicRequest(): CreateTopicRequest {
  return { $type: "wings.v1.cluster_metadata.CreateTopicRequest", parent: "", topicId: "", topic: undefined };
}

export const CreateTopicRequest: MessageFns<CreateTopicRequest, "wings.v1.cluster_metadata.CreateTopicRequest"> = {
  $type: "wings.v1.cluster_metadata.CreateTopicRequest" as const,

  encode(message: CreateTopicRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.topicId !== "") {
      writer.uint32(18).string(message.topicId);
    }
    if (message.topic !== undefined) {
      Topic.encode(message.topic, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateTopicRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateTopicRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.topicId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.topic = Topic.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateTopicRequest {
    return {
      $type: CreateTopicRequest.$type,
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      topicId: isSet(object.topicId) ? globalThis.String(object.topicId) : "",
      topic: isSet(object.topic) ? Topic.fromJSON(object.topic) : undefined,
    };
  },

  toJSON(message: CreateTopicRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.topicId !== "") {
      obj.topicId = message.topicId;
    }
    if (message.topic !== undefined) {
      obj.topic = Topic.toJSON(message.topic);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateTopicRequest>, I>>(base?: I): CreateTopicRequest {
    return CreateTopicRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateTopicRequest>, I>>(object: I): CreateTopicRequest {
    const message = createBaseCreateTopicRequest() as any;
    message.parent = object.parent ?? "";
    message.topicId = object.topicId ?? "";
    message.topic = (object.topic !== undefined && object.topic !== null) ? Topic.fromPartial(object.topic) : undefined;
    return message;
  },
};

messageTypeRegistry.set(CreateTopicRequest.$type, CreateTopicRequest);

function createBaseGetTopicRequest(): GetTopicRequest {
  return { $type: "wings.v1.cluster_metadata.GetTopicRequest", name: "" };
}

export const GetTopicRequest: MessageFns<GetTopicRequest, "wings.v1.cluster_metadata.GetTopicRequest"> = {
  $type: "wings.v1.cluster_metadata.GetTopicRequest" as const,

  encode(message: GetTopicRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTopicRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTopicRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetTopicRequest {
    return { $type: GetTopicRequest.$type, name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetTopicRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetTopicRequest>, I>>(base?: I): GetTopicRequest {
    return GetTopicRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetTopicRequest>, I>>(object: I): GetTopicRequest {
    const message = createBaseGetTopicRequest() as any;
    message.name = object.name ?? "";
    return message;
  },
};

messageTypeRegistry.set(GetTopicRequest.$type, GetTopicRequest);

function createBaseListTopicsRequest(): ListTopicsRequest {
  return {
    $type: "wings.v1.cluster_metadata.ListTopicsRequest",
    parent: "",
    pageSize: undefined,
    pageToken: undefined,
  };
}

export const ListTopicsRequest: MessageFns<ListTopicsRequest, "wings.v1.cluster_metadata.ListTopicsRequest"> = {
  $type: "wings.v1.cluster_metadata.ListTopicsRequest" as const,

  encode(message: ListTopicsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== undefined) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTopicsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTopicsRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTopicsRequest {
    return {
      $type: ListTopicsRequest.$type,
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : undefined,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : undefined,
    };
  },

  toJSON(message: ListTopicsRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTopicsRequest>, I>>(base?: I): ListTopicsRequest {
    return ListTopicsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTopicsRequest>, I>>(object: I): ListTopicsRequest {
    const message = createBaseListTopicsRequest() as any;
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? undefined;
    message.pageToken = object.pageToken ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ListTopicsRequest.$type, ListTopicsRequest);

function createBaseListTopicsResponse(): ListTopicsResponse {
  return { $type: "wings.v1.cluster_metadata.ListTopicsResponse", topics: [], nextPageToken: "" };
}

export const ListTopicsResponse: MessageFns<ListTopicsResponse, "wings.v1.cluster_metadata.ListTopicsResponse"> = {
  $type: "wings.v1.cluster_metadata.ListTopicsResponse" as const,

  encode(message: ListTopicsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.topics) {
      Topic.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListTopicsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListTopicsResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.topics.push(Topic.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListTopicsResponse {
    return {
      $type: ListTopicsResponse.$type,
      topics: globalThis.Array.isArray(object?.topics) ? object.topics.map((e: any) => Topic.fromJSON(e)) : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListTopicsResponse): unknown {
    const obj: any = {};
    if (message.topics?.length) {
      obj.topics = message.topics.map((e) => Topic.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListTopicsResponse>, I>>(base?: I): ListTopicsResponse {
    return ListTopicsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListTopicsResponse>, I>>(object: I): ListTopicsResponse {
    const message = createBaseListTopicsResponse() as any;
    message.topics = object.topics?.map((e) => Topic.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

messageTypeRegistry.set(ListTopicsResponse.$type, ListTopicsResponse);

function createBaseDeleteTopicRequest(): DeleteTopicRequest {
  return { $type: "wings.v1.cluster_metadata.DeleteTopicRequest", name: "", force: false };
}

export const DeleteTopicRequest: MessageFns<DeleteTopicRequest, "wings.v1.cluster_metadata.DeleteTopicRequest"> = {
  $type: "wings.v1.cluster_metadata.DeleteTopicRequest" as const,

  encode(message: DeleteTopicRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.force !== false) {
      writer.uint32(16).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteTopicRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteTopicRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.force = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteTopicRequest {
    return {
      $type: DeleteTopicRequest.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: DeleteTopicRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteTopicRequest>, I>>(base?: I): DeleteTopicRequest {
    return DeleteTopicRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteTopicRequest>, I>>(object: I): DeleteTopicRequest {
    const message = createBaseDeleteTopicRequest() as any;
    message.name = object.name ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

messageTypeRegistry.set(DeleteTopicRequest.$type, DeleteTopicRequest);

function createBaseTopic(): Topic {
  return {
    $type: "wings.v1.cluster_metadata.Topic",
    name: "",
    fields: new Uint8Array(0),
    description: undefined,
    partitionKey: undefined,
    compaction: undefined,
  };
}

export const Topic: MessageFns<Topic, "wings.v1.cluster_metadata.Topic"> = {
  $type: "wings.v1.cluster_metadata.Topic" as const,

  encode(message: Topic, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.fields.length !== 0) {
      writer.uint32(18).bytes(message.fields);
    }
    if (message.description !== undefined) {
      writer.uint32(26).string(message.description);
    }
    if (message.partitionKey !== undefined) {
      writer.uint32(32).uint32(message.partitionKey);
    }
    if (message.compaction !== undefined) {
      CompactionConfiguration.encode(message.compaction, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Topic {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTopic() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fields = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.partitionKey = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.compaction = CompactionConfiguration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Topic {
    return {
      $type: Topic.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      fields: isSet(object.fields) ? bytesFromBase64(object.fields) : new Uint8Array(0),
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      partitionKey: isSet(object.partitionKey) ? globalThis.Number(object.partitionKey) : undefined,
      compaction: isSet(object.compaction) ? CompactionConfiguration.fromJSON(object.compaction) : undefined,
    };
  },

  toJSON(message: Topic): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.fields.length !== 0) {
      obj.fields = base64FromBytes(message.fields);
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.partitionKey !== undefined) {
      obj.partitionKey = Math.round(message.partitionKey);
    }
    if (message.compaction !== undefined) {
      obj.compaction = CompactionConfiguration.toJSON(message.compaction);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Topic>, I>>(base?: I): Topic {
    return Topic.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Topic>, I>>(object: I): Topic {
    const message = createBaseTopic() as any;
    message.name = object.name ?? "";
    message.fields = object.fields ?? new Uint8Array(0);
    message.description = object.description ?? undefined;
    message.partitionKey = object.partitionKey ?? undefined;
    message.compaction = (object.compaction !== undefined && object.compaction !== null)
      ? CompactionConfiguration.fromPartial(object.compaction)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(Topic.$type, Topic);

function createBaseCompactionConfiguration(): CompactionConfiguration {
  return { $type: "wings.v1.cluster_metadata.CompactionConfiguration", freshnessSeconds: 0n, ttlSeconds: undefined };
}

export const CompactionConfiguration: MessageFns<
  CompactionConfiguration,
  "wings.v1.cluster_metadata.CompactionConfiguration"
> = {
  $type: "wings.v1.cluster_metadata.CompactionConfiguration" as const,

  encode(message: CompactionConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.freshnessSeconds !== 0n) {
      if (BigInt.asUintN(64, message.freshnessSeconds) !== message.freshnessSeconds) {
        throw new globalThis.Error("value provided for field message.freshnessSeconds of type uint64 too large");
      }
      writer.uint32(8).uint64(message.freshnessSeconds);
    }
    if (message.ttlSeconds !== undefined) {
      if (BigInt.asUintN(64, message.ttlSeconds) !== message.ttlSeconds) {
        throw new globalThis.Error("value provided for field message.ttlSeconds of type uint64 too large");
      }
      writer.uint32(16).uint64(message.ttlSeconds);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompactionConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompactionConfiguration() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.freshnessSeconds = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.ttlSeconds = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompactionConfiguration {
    return {
      $type: CompactionConfiguration.$type,
      freshnessSeconds: isSet(object.freshnessSeconds) ? BigInt(object.freshnessSeconds) : 0n,
      ttlSeconds: isSet(object.ttlSeconds) ? BigInt(object.ttlSeconds) : undefined,
    };
  },

  toJSON(message: CompactionConfiguration): unknown {
    const obj: any = {};
    if (message.freshnessSeconds !== 0n) {
      obj.freshnessSeconds = message.freshnessSeconds.toString();
    }
    if (message.ttlSeconds !== undefined) {
      obj.ttlSeconds = message.ttlSeconds.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CompactionConfiguration>, I>>(base?: I): CompactionConfiguration {
    return CompactionConfiguration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CompactionConfiguration>, I>>(object: I): CompactionConfiguration {
    const message = createBaseCompactionConfiguration() as any;
    message.freshnessSeconds = object.freshnessSeconds ?? 0n;
    message.ttlSeconds = object.ttlSeconds ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(CompactionConfiguration.$type, CompactionConfiguration);

function createBaseCreateObjectStoreRequest(): CreateObjectStoreRequest {
  return {
    $type: "wings.v1.cluster_metadata.CreateObjectStoreRequest",
    parent: "",
    objectStoreId: "",
    objectStore: undefined,
  };
}

export const CreateObjectStoreRequest: MessageFns<
  CreateObjectStoreRequest,
  "wings.v1.cluster_metadata.CreateObjectStoreRequest"
> = {
  $type: "wings.v1.cluster_metadata.CreateObjectStoreRequest" as const,

  encode(message: CreateObjectStoreRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.objectStoreId !== "") {
      writer.uint32(18).string(message.objectStoreId);
    }
    if (message.objectStore !== undefined) {
      ObjectStore.encode(message.objectStore, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateObjectStoreRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateObjectStoreRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.objectStoreId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.objectStore = ObjectStore.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateObjectStoreRequest {
    return {
      $type: CreateObjectStoreRequest.$type,
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      objectStoreId: isSet(object.objectStoreId) ? globalThis.String(object.objectStoreId) : "",
      objectStore: isSet(object.objectStore) ? ObjectStore.fromJSON(object.objectStore) : undefined,
    };
  },

  toJSON(message: CreateObjectStoreRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.objectStoreId !== "") {
      obj.objectStoreId = message.objectStoreId;
    }
    if (message.objectStore !== undefined) {
      obj.objectStore = ObjectStore.toJSON(message.objectStore);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateObjectStoreRequest>, I>>(base?: I): CreateObjectStoreRequest {
    return CreateObjectStoreRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateObjectStoreRequest>, I>>(object: I): CreateObjectStoreRequest {
    const message = createBaseCreateObjectStoreRequest() as any;
    message.parent = object.parent ?? "";
    message.objectStoreId = object.objectStoreId ?? "";
    message.objectStore = (object.objectStore !== undefined && object.objectStore !== null)
      ? ObjectStore.fromPartial(object.objectStore)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(CreateObjectStoreRequest.$type, CreateObjectStoreRequest);

function createBaseGetObjectStoreRequest(): GetObjectStoreRequest {
  return { $type: "wings.v1.cluster_metadata.GetObjectStoreRequest", name: "" };
}

export const GetObjectStoreRequest: MessageFns<
  GetObjectStoreRequest,
  "wings.v1.cluster_metadata.GetObjectStoreRequest"
> = {
  $type: "wings.v1.cluster_metadata.GetObjectStoreRequest" as const,

  encode(message: GetObjectStoreRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetObjectStoreRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetObjectStoreRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetObjectStoreRequest {
    return { $type: GetObjectStoreRequest.$type, name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetObjectStoreRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetObjectStoreRequest>, I>>(base?: I): GetObjectStoreRequest {
    return GetObjectStoreRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetObjectStoreRequest>, I>>(object: I): GetObjectStoreRequest {
    const message = createBaseGetObjectStoreRequest() as any;
    message.name = object.name ?? "";
    return message;
  },
};

messageTypeRegistry.set(GetObjectStoreRequest.$type, GetObjectStoreRequest);

function createBaseListObjectStoresRequest(): ListObjectStoresRequest {
  return {
    $type: "wings.v1.cluster_metadata.ListObjectStoresRequest",
    parent: "",
    pageSize: undefined,
    pageToken: undefined,
  };
}

export const ListObjectStoresRequest: MessageFns<
  ListObjectStoresRequest,
  "wings.v1.cluster_metadata.ListObjectStoresRequest"
> = {
  $type: "wings.v1.cluster_metadata.ListObjectStoresRequest" as const,

  encode(message: ListObjectStoresRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.pageSize !== undefined) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      writer.uint32(26).string(message.pageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListObjectStoresRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListObjectStoresRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListObjectStoresRequest {
    return {
      $type: ListObjectStoresRequest.$type,
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : undefined,
      pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : undefined,
    };
  },

  toJSON(message: ListObjectStoresRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.pageSize !== undefined) {
      obj.pageSize = Math.round(message.pageSize);
    }
    if (message.pageToken !== undefined) {
      obj.pageToken = message.pageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListObjectStoresRequest>, I>>(base?: I): ListObjectStoresRequest {
    return ListObjectStoresRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListObjectStoresRequest>, I>>(object: I): ListObjectStoresRequest {
    const message = createBaseListObjectStoresRequest() as any;
    message.parent = object.parent ?? "";
    message.pageSize = object.pageSize ?? undefined;
    message.pageToken = object.pageToken ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(ListObjectStoresRequest.$type, ListObjectStoresRequest);

function createBaseListObjectStoresResponse(): ListObjectStoresResponse {
  return { $type: "wings.v1.cluster_metadata.ListObjectStoresResponse", objectStores: [], nextPageToken: "" };
}

export const ListObjectStoresResponse: MessageFns<
  ListObjectStoresResponse,
  "wings.v1.cluster_metadata.ListObjectStoresResponse"
> = {
  $type: "wings.v1.cluster_metadata.ListObjectStoresResponse" as const,

  encode(message: ListObjectStoresResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.objectStores) {
      ObjectStore.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListObjectStoresResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListObjectStoresResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.objectStores.push(ObjectStore.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListObjectStoresResponse {
    return {
      $type: ListObjectStoresResponse.$type,
      objectStores: globalThis.Array.isArray(object?.objectStores)
        ? object.objectStores.map((e: any) => ObjectStore.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListObjectStoresResponse): unknown {
    const obj: any = {};
    if (message.objectStores?.length) {
      obj.objectStores = message.objectStores.map((e) => ObjectStore.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListObjectStoresResponse>, I>>(base?: I): ListObjectStoresResponse {
    return ListObjectStoresResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListObjectStoresResponse>, I>>(object: I): ListObjectStoresResponse {
    const message = createBaseListObjectStoresResponse() as any;
    message.objectStores = object.objectStores?.map((e) => ObjectStore.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

messageTypeRegistry.set(ListObjectStoresResponse.$type, ListObjectStoresResponse);

function createBaseDeleteObjectStoreRequest(): DeleteObjectStoreRequest {
  return { $type: "wings.v1.cluster_metadata.DeleteObjectStoreRequest", name: "" };
}

export const DeleteObjectStoreRequest: MessageFns<
  DeleteObjectStoreRequest,
  "wings.v1.cluster_metadata.DeleteObjectStoreRequest"
> = {
  $type: "wings.v1.cluster_metadata.DeleteObjectStoreRequest" as const,

  encode(message: DeleteObjectStoreRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteObjectStoreRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteObjectStoreRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteObjectStoreRequest {
    return { $type: DeleteObjectStoreRequest.$type, name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteObjectStoreRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteObjectStoreRequest>, I>>(base?: I): DeleteObjectStoreRequest {
    return DeleteObjectStoreRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteObjectStoreRequest>, I>>(object: I): DeleteObjectStoreRequest {
    const message = createBaseDeleteObjectStoreRequest() as any;
    message.name = object.name ?? "";
    return message;
  },
};

messageTypeRegistry.set(DeleteObjectStoreRequest.$type, DeleteObjectStoreRequest);

function createBaseObjectStore(): ObjectStore {
  return { $type: "wings.v1.cluster_metadata.ObjectStore", name: "", objectStoreConfig: undefined };
}

export const ObjectStore: MessageFns<ObjectStore, "wings.v1.cluster_metadata.ObjectStore"> = {
  $type: "wings.v1.cluster_metadata.ObjectStore" as const,

  encode(message: ObjectStore, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    switch (message.objectStoreConfig?.$case) {
      case "aws":
        AwsConfiguration.encode(message.objectStoreConfig.aws, writer.uint32(18).fork()).join();
        break;
      case "azure":
        AzureConfiguration.encode(message.objectStoreConfig.azure, writer.uint32(26).fork()).join();
        break;
      case "google":
        GoogleConfiguration.encode(message.objectStoreConfig.google, writer.uint32(34).fork()).join();
        break;
      case "s3Compatible":
        S3CompatibleConfiguration.encode(message.objectStoreConfig.s3Compatible, writer.uint32(42).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ObjectStore {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseObjectStore() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.objectStoreConfig = { $case: "aws", aws: AwsConfiguration.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.objectStoreConfig = { $case: "azure", azure: AzureConfiguration.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.objectStoreConfig = { $case: "google", google: GoogleConfiguration.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.objectStoreConfig = {
            $case: "s3Compatible",
            s3Compatible: S3CompatibleConfiguration.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ObjectStore {
    return {
      $type: ObjectStore.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      objectStoreConfig: isSet(object.aws)
        ? { $case: "aws", aws: AwsConfiguration.fromJSON(object.aws) }
        : isSet(object.azure)
        ? { $case: "azure", azure: AzureConfiguration.fromJSON(object.azure) }
        : isSet(object.google)
        ? { $case: "google", google: GoogleConfiguration.fromJSON(object.google) }
        : isSet(object.s3Compatible)
        ? { $case: "s3Compatible", s3Compatible: S3CompatibleConfiguration.fromJSON(object.s3Compatible) }
        : undefined,
    };
  },

  toJSON(message: ObjectStore): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.objectStoreConfig?.$case === "aws") {
      obj.aws = AwsConfiguration.toJSON(message.objectStoreConfig.aws);
    } else if (message.objectStoreConfig?.$case === "azure") {
      obj.azure = AzureConfiguration.toJSON(message.objectStoreConfig.azure);
    } else if (message.objectStoreConfig?.$case === "google") {
      obj.google = GoogleConfiguration.toJSON(message.objectStoreConfig.google);
    } else if (message.objectStoreConfig?.$case === "s3Compatible") {
      obj.s3Compatible = S3CompatibleConfiguration.toJSON(message.objectStoreConfig.s3Compatible);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ObjectStore>, I>>(base?: I): ObjectStore {
    return ObjectStore.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ObjectStore>, I>>(object: I): ObjectStore {
    const message = createBaseObjectStore() as any;
    message.name = object.name ?? "";
    switch (object.objectStoreConfig?.$case) {
      case "aws": {
        if (object.objectStoreConfig?.aws !== undefined && object.objectStoreConfig?.aws !== null) {
          message.objectStoreConfig = { $case: "aws", aws: AwsConfiguration.fromPartial(object.objectStoreConfig.aws) };
        }
        break;
      }
      case "azure": {
        if (object.objectStoreConfig?.azure !== undefined && object.objectStoreConfig?.azure !== null) {
          message.objectStoreConfig = {
            $case: "azure",
            azure: AzureConfiguration.fromPartial(object.objectStoreConfig.azure),
          };
        }
        break;
      }
      case "google": {
        if (object.objectStoreConfig?.google !== undefined && object.objectStoreConfig?.google !== null) {
          message.objectStoreConfig = {
            $case: "google",
            google: GoogleConfiguration.fromPartial(object.objectStoreConfig.google),
          };
        }
        break;
      }
      case "s3Compatible": {
        if (object.objectStoreConfig?.s3Compatible !== undefined && object.objectStoreConfig?.s3Compatible !== null) {
          message.objectStoreConfig = {
            $case: "s3Compatible",
            s3Compatible: S3CompatibleConfiguration.fromPartial(object.objectStoreConfig.s3Compatible),
          };
        }
        break;
      }
    }
    return message;
  },
};

messageTypeRegistry.set(ObjectStore.$type, ObjectStore);

function createBaseAwsConfiguration(): AwsConfiguration {
  return {
    $type: "wings.v1.cluster_metadata.AwsConfiguration",
    bucketName: "",
    prefix: undefined,
    accessKeyId: "",
    secretAccessKey: "",
    region: undefined,
  };
}

export const AwsConfiguration: MessageFns<AwsConfiguration, "wings.v1.cluster_metadata.AwsConfiguration"> = {
  $type: "wings.v1.cluster_metadata.AwsConfiguration" as const,

  encode(message: AwsConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucketName !== "") {
      writer.uint32(10).string(message.bucketName);
    }
    if (message.prefix !== undefined) {
      writer.uint32(18).string(message.prefix);
    }
    if (message.accessKeyId !== "") {
      writer.uint32(26).string(message.accessKeyId);
    }
    if (message.secretAccessKey !== "") {
      writer.uint32(34).string(message.secretAccessKey);
    }
    if (message.region !== undefined) {
      writer.uint32(42).string(message.region);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AwsConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAwsConfiguration() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bucketName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.prefix = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.accessKeyId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.secretAccessKey = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.region = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AwsConfiguration {
    return {
      $type: AwsConfiguration.$type,
      bucketName: isSet(object.bucketName) ? globalThis.String(object.bucketName) : "",
      prefix: isSet(object.prefix) ? globalThis.String(object.prefix) : undefined,
      accessKeyId: isSet(object.accessKeyId) ? globalThis.String(object.accessKeyId) : "",
      secretAccessKey: isSet(object.secretAccessKey) ? globalThis.String(object.secretAccessKey) : "",
      region: isSet(object.region) ? globalThis.String(object.region) : undefined,
    };
  },

  toJSON(message: AwsConfiguration): unknown {
    const obj: any = {};
    if (message.bucketName !== "") {
      obj.bucketName = message.bucketName;
    }
    if (message.prefix !== undefined) {
      obj.prefix = message.prefix;
    }
    if (message.accessKeyId !== "") {
      obj.accessKeyId = message.accessKeyId;
    }
    if (message.secretAccessKey !== "") {
      obj.secretAccessKey = message.secretAccessKey;
    }
    if (message.region !== undefined) {
      obj.region = message.region;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AwsConfiguration>, I>>(base?: I): AwsConfiguration {
    return AwsConfiguration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AwsConfiguration>, I>>(object: I): AwsConfiguration {
    const message = createBaseAwsConfiguration() as any;
    message.bucketName = object.bucketName ?? "";
    message.prefix = object.prefix ?? undefined;
    message.accessKeyId = object.accessKeyId ?? "";
    message.secretAccessKey = object.secretAccessKey ?? "";
    message.region = object.region ?? undefined;
    return message;
  },
};

messageTypeRegistry.set(AwsConfiguration.$type, AwsConfiguration);

function createBaseAzureConfiguration(): AzureConfiguration {
  return {
    $type: "wings.v1.cluster_metadata.AzureConfiguration",
    containerName: "",
    prefix: undefined,
    storageAccountName: "",
    storageAccountKey: "",
  };
}

export const AzureConfiguration: MessageFns<AzureConfiguration, "wings.v1.cluster_metadata.AzureConfiguration"> = {
  $type: "wings.v1.cluster_metadata.AzureConfiguration" as const,

  encode(message: AzureConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.containerName !== "") {
      writer.uint32(10).string(message.containerName);
    }
    if (message.prefix !== undefined) {
      writer.uint32(18).string(message.prefix);
    }
    if (message.storageAccountName !== "") {
      writer.uint32(26).string(message.storageAccountName);
    }
    if (message.storageAccountKey !== "") {
      writer.uint32(34).string(message.storageAccountKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AzureConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAzureConfiguration() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.containerName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.prefix = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.storageAccountName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.storageAccountKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AzureConfiguration {
    return {
      $type: AzureConfiguration.$type,
      containerName: isSet(object.containerName) ? globalThis.String(object.containerName) : "",
      prefix: isSet(object.prefix) ? globalThis.String(object.prefix) : undefined,
      storageAccountName: isSet(object.storageAccountName) ? globalThis.String(object.storageAccountName) : "",
      storageAccountKey: isSet(object.storageAccountKey) ? globalThis.String(object.storageAccountKey) : "",
    };
  },

  toJSON(message: AzureConfiguration): unknown {
    const obj: any = {};
    if (message.containerName !== "") {
      obj.containerName = message.containerName;
    }
    if (message.prefix !== undefined) {
      obj.prefix = message.prefix;
    }
    if (message.storageAccountName !== "") {
      obj.storageAccountName = message.storageAccountName;
    }
    if (message.storageAccountKey !== "") {
      obj.storageAccountKey = message.storageAccountKey;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AzureConfiguration>, I>>(base?: I): AzureConfiguration {
    return AzureConfiguration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AzureConfiguration>, I>>(object: I): AzureConfiguration {
    const message = createBaseAzureConfiguration() as any;
    message.containerName = object.containerName ?? "";
    message.prefix = object.prefix ?? undefined;
    message.storageAccountName = object.storageAccountName ?? "";
    message.storageAccountKey = object.storageAccountKey ?? "";
    return message;
  },
};

messageTypeRegistry.set(AzureConfiguration.$type, AzureConfiguration);

function createBaseGoogleConfiguration(): GoogleConfiguration {
  return {
    $type: "wings.v1.cluster_metadata.GoogleConfiguration",
    bucketName: "",
    prefix: undefined,
    serviceAccount: "",
    serviceAccountKey: "",
  };
}

export const GoogleConfiguration: MessageFns<GoogleConfiguration, "wings.v1.cluster_metadata.GoogleConfiguration"> = {
  $type: "wings.v1.cluster_metadata.GoogleConfiguration" as const,

  encode(message: GoogleConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucketName !== "") {
      writer.uint32(10).string(message.bucketName);
    }
    if (message.prefix !== undefined) {
      writer.uint32(18).string(message.prefix);
    }
    if (message.serviceAccount !== "") {
      writer.uint32(26).string(message.serviceAccount);
    }
    if (message.serviceAccountKey !== "") {
      writer.uint32(34).string(message.serviceAccountKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoogleConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoogleConfiguration() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bucketName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.prefix = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.serviceAccount = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.serviceAccountKey = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GoogleConfiguration {
    return {
      $type: GoogleConfiguration.$type,
      bucketName: isSet(object.bucketName) ? globalThis.String(object.bucketName) : "",
      prefix: isSet(object.prefix) ? globalThis.String(object.prefix) : undefined,
      serviceAccount: isSet(object.serviceAccount) ? globalThis.String(object.serviceAccount) : "",
      serviceAccountKey: isSet(object.serviceAccountKey) ? globalThis.String(object.serviceAccountKey) : "",
    };
  },

  toJSON(message: GoogleConfiguration): unknown {
    const obj: any = {};
    if (message.bucketName !== "") {
      obj.bucketName = message.bucketName;
    }
    if (message.prefix !== undefined) {
      obj.prefix = message.prefix;
    }
    if (message.serviceAccount !== "") {
      obj.serviceAccount = message.serviceAccount;
    }
    if (message.serviceAccountKey !== "") {
      obj.serviceAccountKey = message.serviceAccountKey;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GoogleConfiguration>, I>>(base?: I): GoogleConfiguration {
    return GoogleConfiguration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GoogleConfiguration>, I>>(object: I): GoogleConfiguration {
    const message = createBaseGoogleConfiguration() as any;
    message.bucketName = object.bucketName ?? "";
    message.prefix = object.prefix ?? undefined;
    message.serviceAccount = object.serviceAccount ?? "";
    message.serviceAccountKey = object.serviceAccountKey ?? "";
    return message;
  },
};

messageTypeRegistry.set(GoogleConfiguration.$type, GoogleConfiguration);

function createBaseS3CompatibleConfiguration(): S3CompatibleConfiguration {
  return {
    $type: "wings.v1.cluster_metadata.S3CompatibleConfiguration",
    bucketName: "",
    prefix: undefined,
    accessKeyId: "",
    secretAccessKey: "",
    region: undefined,
    endpoint: "",
  };
}

export const S3CompatibleConfiguration: MessageFns<
  S3CompatibleConfiguration,
  "wings.v1.cluster_metadata.S3CompatibleConfiguration"
> = {
  $type: "wings.v1.cluster_metadata.S3CompatibleConfiguration" as const,

  encode(message: S3CompatibleConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucketName !== "") {
      writer.uint32(10).string(message.bucketName);
    }
    if (message.prefix !== undefined) {
      writer.uint32(18).string(message.prefix);
    }
    if (message.accessKeyId !== "") {
      writer.uint32(26).string(message.accessKeyId);
    }
    if (message.secretAccessKey !== "") {
      writer.uint32(34).string(message.secretAccessKey);
    }
    if (message.region !== undefined) {
      writer.uint32(42).string(message.region);
    }
    if (message.endpoint !== "") {
      writer.uint32(50).string(message.endpoint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): S3CompatibleConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseS3CompatibleConfiguration() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bucketName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.prefix = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.accessKeyId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.secretAccessKey = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.region = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.endpoint = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): S3CompatibleConfiguration {
    return {
      $type: S3CompatibleConfiguration.$type,
      bucketName: isSet(object.bucketName) ? globalThis.String(object.bucketName) : "",
      prefix: isSet(object.prefix) ? globalThis.String(object.prefix) : undefined,
      accessKeyId: isSet(object.accessKeyId) ? globalThis.String(object.accessKeyId) : "",
      secretAccessKey: isSet(object.secretAccessKey) ? globalThis.String(object.secretAccessKey) : "",
      region: isSet(object.region) ? globalThis.String(object.region) : undefined,
      endpoint: isSet(object.endpoint) ? globalThis.String(object.endpoint) : "",
    };
  },

  toJSON(message: S3CompatibleConfiguration): unknown {
    const obj: any = {};
    if (message.bucketName !== "") {
      obj.bucketName = message.bucketName;
    }
    if (message.prefix !== undefined) {
      obj.prefix = message.prefix;
    }
    if (message.accessKeyId !== "") {
      obj.accessKeyId = message.accessKeyId;
    }
    if (message.secretAccessKey !== "") {
      obj.secretAccessKey = message.secretAccessKey;
    }
    if (message.region !== undefined) {
      obj.region = message.region;
    }
    if (message.endpoint !== "") {
      obj.endpoint = message.endpoint;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<S3CompatibleConfiguration>, I>>(base?: I): S3CompatibleConfiguration {
    return S3CompatibleConfiguration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<S3CompatibleConfiguration>, I>>(object: I): S3CompatibleConfiguration {
    const message = createBaseS3CompatibleConfiguration() as any;
    message.bucketName = object.bucketName ?? "";
    message.prefix = object.prefix ?? undefined;
    message.accessKeyId = object.accessKeyId ?? "";
    message.secretAccessKey = object.secretAccessKey ?? "";
    message.region = object.region ?? undefined;
    message.endpoint = object.endpoint ?? "";
    return message;
  },
};

messageTypeRegistry.set(S3CompatibleConfiguration.$type, S3CompatibleConfiguration);

function createBaseCreateDataLakeRequest(): CreateDataLakeRequest {
  return { $type: "wings.v1.cluster_metadata.CreateDataLakeRequest", parent: "", dataLakeId: "", dataLake: undefined };
}

export const CreateDataLakeRequest: MessageFns<
  CreateDataLakeRequest,
  "wings.v1.cluster_metadata.CreateDataLakeRequest"
> = {
  $type: "wings.v1.cluster_metadata.CreateDataLakeRequest" as const,

  encode(message: CreateDataLakeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.parent !== "") {
      writer.uint32(10).string(message.parent);
    }
    if (message.dataLakeId !== "") {
      writer.uint32(18).string(message.dataLakeId);
    }
    if (message.dataLake !== undefined) {
      DataLake.encode(message.dataLake, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateDataLakeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateDataLakeRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dataLakeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dataLake = DataLake.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateDataLakeRequest {
    return {
      $type: CreateDataLakeRequest.$type,
      parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
      dataLakeId: isSet(object.dataLakeId) ? globalThis.String(object.dataLakeId) : "",
      dataLake: isSet(object.dataLake) ? DataLake.fromJSON(object.dataLake) : undefined,
    };
  },

  toJSON(message: CreateDataLakeRequest): unknown {
    const obj: any = {};
    if (message.parent !== "") {
      obj.parent = message.parent;
    }
    if (message.dataLakeId !== "") {
      obj.dataLakeId = message.dataLakeId;
    }
    if (message.dataLake !== undefined) {
      obj.dataLake = DataLake.toJSON(message.dataLake);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateDataLakeRequest>, I>>(base?: I): CreateDataLakeRequest {
    return CreateDataLakeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateDataLakeRequest>, I>>(object: I): CreateDataLakeRequest {
    const message = createBaseCreateDataLakeRequest() as any;
    message.parent = object.parent ?? "";
    message.dataLakeId = object.dataLakeId ?? "";
    message.dataLake = (object.dataLake !== undefined && object.dataLake !== null)
      ? DataLake.fromPartial(object.dataLake)
      : undefined;
    return message;
  },
};

messageTypeRegistry.set(CreateDataLakeRequest.$type, CreateDataLakeRequest);

function createBaseGetDataLakeRequest(): GetDataLakeRequest {
  return { $type: "wings.v1.cluster_metadata.GetDataLakeRequest", name: "" };
}

export const GetDataLakeRequest: MessageFns<GetDataLakeRequest, "wings.v1.cluster_metadata.GetDataLakeRequest"> = {
  $type: "wings.v1.cluster_metadata.GetDataLakeRequest" as const,

  encode(message: GetDataLakeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDataLakeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDataLakeRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetDataLakeRequest {
    return { $type: GetDataLakeRequest.$type, name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: GetDataLakeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetDataLakeRequest>, I>>(base?: I): GetDataLakeRequest {
    return GetDataLakeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetDataLakeRequest>, I>>(object: I): GetDataLakeRequest {
    const message = createBaseGetDataLakeRequest() as any;
    message.name = object.name ?? "";
    return message;
  },
};

messageTypeRegistry.set(GetDataLakeRequest.$type, GetDataLakeRequest);

function createBaseListDataLakesRequest(): ListDataLakesRequest {
  return {
    $type: "wings.v1.cluster_metadata.ListDataLakesRequest",
    parent: "",
    pageSize: undefined,
    pageToken: undefined,
  };
}

export const ListDataLakesRequest: MessageFns<ListDataLakesRequest, "wings.v1.cluster_metadata.ListDataLakesRequest"> =
  {
    $type: "wings.v1.cluster_metadata.ListDataLakesRequest" as const,

    encode(message: ListDataLakesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
      if (message.parent !== "") {
        writer.uint32(10).string(message.parent);
      }
      if (message.pageSize !== undefined) {
        writer.uint32(16).int32(message.pageSize);
      }
      if (message.pageToken !== undefined) {
        writer.uint32(26).string(message.pageToken);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): ListDataLakesRequest {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseListDataLakesRequest() as any;
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.parent = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.pageSize = reader.int32();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.pageToken = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ListDataLakesRequest {
      return {
        $type: ListDataLakesRequest.$type,
        parent: isSet(object.parent) ? globalThis.String(object.parent) : "",
        pageSize: isSet(object.pageSize) ? globalThis.Number(object.pageSize) : undefined,
        pageToken: isSet(object.pageToken) ? globalThis.String(object.pageToken) : undefined,
      };
    },

    toJSON(message: ListDataLakesRequest): unknown {
      const obj: any = {};
      if (message.parent !== "") {
        obj.parent = message.parent;
      }
      if (message.pageSize !== undefined) {
        obj.pageSize = Math.round(message.pageSize);
      }
      if (message.pageToken !== undefined) {
        obj.pageToken = message.pageToken;
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<ListDataLakesRequest>, I>>(base?: I): ListDataLakesRequest {
      return ListDataLakesRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<ListDataLakesRequest>, I>>(object: I): ListDataLakesRequest {
      const message = createBaseListDataLakesRequest() as any;
      message.parent = object.parent ?? "";
      message.pageSize = object.pageSize ?? undefined;
      message.pageToken = object.pageToken ?? undefined;
      return message;
    },
  };

messageTypeRegistry.set(ListDataLakesRequest.$type, ListDataLakesRequest);

function createBaseListDataLakesResponse(): ListDataLakesResponse {
  return { $type: "wings.v1.cluster_metadata.ListDataLakesResponse", dataLakes: [], nextPageToken: "" };
}

export const ListDataLakesResponse: MessageFns<
  ListDataLakesResponse,
  "wings.v1.cluster_metadata.ListDataLakesResponse"
> = {
  $type: "wings.v1.cluster_metadata.ListDataLakesResponse" as const,

  encode(message: ListDataLakesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dataLakes) {
      DataLake.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListDataLakesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListDataLakesResponse() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dataLakes.push(DataLake.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListDataLakesResponse {
    return {
      $type: ListDataLakesResponse.$type,
      dataLakes: globalThis.Array.isArray(object?.dataLakes)
        ? object.dataLakes.map((e: any) => DataLake.fromJSON(e))
        : [],
      nextPageToken: isSet(object.nextPageToken) ? globalThis.String(object.nextPageToken) : "",
    };
  },

  toJSON(message: ListDataLakesResponse): unknown {
    const obj: any = {};
    if (message.dataLakes?.length) {
      obj.dataLakes = message.dataLakes.map((e) => DataLake.toJSON(e));
    }
    if (message.nextPageToken !== "") {
      obj.nextPageToken = message.nextPageToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListDataLakesResponse>, I>>(base?: I): ListDataLakesResponse {
    return ListDataLakesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListDataLakesResponse>, I>>(object: I): ListDataLakesResponse {
    const message = createBaseListDataLakesResponse() as any;
    message.dataLakes = object.dataLakes?.map((e) => DataLake.fromPartial(e)) || [];
    message.nextPageToken = object.nextPageToken ?? "";
    return message;
  },
};

messageTypeRegistry.set(ListDataLakesResponse.$type, ListDataLakesResponse);

function createBaseDeleteDataLakeRequest(): DeleteDataLakeRequest {
  return { $type: "wings.v1.cluster_metadata.DeleteDataLakeRequest", name: "" };
}

export const DeleteDataLakeRequest: MessageFns<
  DeleteDataLakeRequest,
  "wings.v1.cluster_metadata.DeleteDataLakeRequest"
> = {
  $type: "wings.v1.cluster_metadata.DeleteDataLakeRequest" as const,

  encode(message: DeleteDataLakeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteDataLakeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteDataLakeRequest() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteDataLakeRequest {
    return { $type: DeleteDataLakeRequest.$type, name: isSet(object.name) ? globalThis.String(object.name) : "" };
  },

  toJSON(message: DeleteDataLakeRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteDataLakeRequest>, I>>(base?: I): DeleteDataLakeRequest {
    return DeleteDataLakeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteDataLakeRequest>, I>>(object: I): DeleteDataLakeRequest {
    const message = createBaseDeleteDataLakeRequest() as any;
    message.name = object.name ?? "";
    return message;
  },
};

messageTypeRegistry.set(DeleteDataLakeRequest.$type, DeleteDataLakeRequest);

function createBaseDataLake(): DataLake {
  return { $type: "wings.v1.cluster_metadata.DataLake", name: "", dataLakeConfig: undefined };
}

export const DataLake: MessageFns<DataLake, "wings.v1.cluster_metadata.DataLake"> = {
  $type: "wings.v1.cluster_metadata.DataLake" as const,

  encode(message: DataLake, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    switch (message.dataLakeConfig?.$case) {
      case "iceberg":
        IcebergConfiguration.encode(message.dataLakeConfig.iceberg, writer.uint32(18).fork()).join();
        break;
      case "parquet":
        ParquetConfiguration.encode(message.dataLakeConfig.parquet, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataLake {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataLake() as any;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dataLakeConfig = { $case: "iceberg", iceberg: IcebergConfiguration.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dataLakeConfig = { $case: "parquet", parquet: ParquetConfiguration.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataLake {
    return {
      $type: DataLake.$type,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      dataLakeConfig: isSet(object.iceberg)
        ? { $case: "iceberg", iceberg: IcebergConfiguration.fromJSON(object.iceberg) }
        : isSet(object.parquet)
        ? { $case: "parquet", parquet: ParquetConfiguration.fromJSON(object.parquet) }
        : undefined,
    };
  },

  toJSON(message: DataLake): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.dataLakeConfig?.$case === "iceberg") {
      obj.iceberg = IcebergConfiguration.toJSON(message.dataLakeConfig.iceberg);
    } else if (message.dataLakeConfig?.$case === "parquet") {
      obj.parquet = ParquetConfiguration.toJSON(message.dataLakeConfig.parquet);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DataLake>, I>>(base?: I): DataLake {
    return DataLake.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DataLake>, I>>(object: I): DataLake {
    const message = createBaseDataLake() as any;
    message.name = object.name ?? "";
    switch (object.dataLakeConfig?.$case) {
      case "iceberg": {
        if (object.dataLakeConfig?.iceberg !== undefined && object.dataLakeConfig?.iceberg !== null) {
          message.dataLakeConfig = {
            $case: "iceberg",
            iceberg: IcebergConfiguration.fromPartial(object.dataLakeConfig.iceberg),
          };
        }
        break;
      }
      case "parquet": {
        if (object.dataLakeConfig?.parquet !== undefined && object.dataLakeConfig?.parquet !== null) {
          message.dataLakeConfig = {
            $case: "parquet",
            parquet: ParquetConfiguration.fromPartial(object.dataLakeConfig.parquet),
          };
        }
        break;
      }
    }
    return message;
  },
};

messageTypeRegistry.set(DataLake.$type, DataLake);

function createBaseIcebergConfiguration(): IcebergConfiguration {
  return { $type: "wings.v1.cluster_metadata.IcebergConfiguration" };
}

export const IcebergConfiguration: MessageFns<IcebergConfiguration, "wings.v1.cluster_metadata.IcebergConfiguration"> =
  {
    $type: "wings.v1.cluster_metadata.IcebergConfiguration" as const,

    encode(_: IcebergConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): IcebergConfiguration {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseIcebergConfiguration() as any;
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(_: any): IcebergConfiguration {
      return { $type: IcebergConfiguration.$type };
    },

    toJSON(_: IcebergConfiguration): unknown {
      const obj: any = {};
      return obj;
    },

    create<I extends Exact<DeepPartial<IcebergConfiguration>, I>>(base?: I): IcebergConfiguration {
      return IcebergConfiguration.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<IcebergConfiguration>, I>>(_: I): IcebergConfiguration {
      const message = createBaseIcebergConfiguration() as any;
      return message;
    },
  };

messageTypeRegistry.set(IcebergConfiguration.$type, IcebergConfiguration);

function createBaseParquetConfiguration(): ParquetConfiguration {
  return { $type: "wings.v1.cluster_metadata.ParquetConfiguration" };
}

export const ParquetConfiguration: MessageFns<ParquetConfiguration, "wings.v1.cluster_metadata.ParquetConfiguration"> =
  {
    $type: "wings.v1.cluster_metadata.ParquetConfiguration" as const,

    encode(_: ParquetConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): ParquetConfiguration {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseParquetConfiguration() as any;
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(_: any): ParquetConfiguration {
      return { $type: ParquetConfiguration.$type };
    },

    toJSON(_: ParquetConfiguration): unknown {
      const obj: any = {};
      return obj;
    },

    create<I extends Exact<DeepPartial<ParquetConfiguration>, I>>(base?: I): ParquetConfiguration {
      return ParquetConfiguration.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<ParquetConfiguration>, I>>(_: I): ParquetConfiguration {
      const message = createBaseParquetConfiguration() as any;
      return message;
    },
  };

messageTypeRegistry.set(ParquetConfiguration.$type, ParquetConfiguration);

/** Cluster metadata service to manage cluster resources. */
export type ClusterMetadataServiceDefinition = typeof ClusterMetadataServiceDefinition;
export const ClusterMetadataServiceDefinition = {
  name: "ClusterMetadataService",
  fullName: "wings.v1.cluster_metadata.ClusterMetadataService",
  methods: {
    /** Create a new tenant. */
    createTenant: {
      name: "CreateTenant",
      requestType: CreateTenantRequest,
      requestStream: false,
      responseType: Tenant,
      responseStream: false,
      options: {},
    },
    /** Return the specified tenant. */
    getTenant: {
      name: "GetTenant",
      requestType: GetTenantRequest,
      requestStream: false,
      responseType: Tenant,
      responseStream: false,
      options: {},
    },
    /** List all tenants. */
    listTenants: {
      name: "ListTenants",
      requestType: ListTenantsRequest,
      requestStream: false,
      responseType: ListTenantsResponse,
      responseStream: false,
      options: {},
    },
    /**
     * Delete a tenant.
     *
     * The request fails if the tenant has any namespace.
     */
    deleteTenant: {
      name: "DeleteTenant",
      requestType: DeleteTenantRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Create a new namespace belonging to a tenant. */
    createNamespace: {
      name: "CreateNamespace",
      requestType: CreateNamespaceRequest,
      requestStream: false,
      responseType: Namespace,
      responseStream: false,
      options: {},
    },
    /** Return the specified namespace. */
    getNamespace: {
      name: "GetNamespace",
      requestType: GetNamespaceRequest,
      requestStream: false,
      responseType: Namespace,
      responseStream: false,
      options: {},
    },
    /** List all namespaces belonging to a tenant. */
    listNamespaces: {
      name: "ListNamespaces",
      requestType: ListNamespacesRequest,
      requestStream: false,
      responseType: ListNamespacesResponse,
      responseStream: false,
      options: {},
    },
    /**
     * Delete a namespace.
     *
     * The request fails if the namespace has any topic.
     */
    deleteNamespace: {
      name: "DeleteNamespace",
      requestType: DeleteNamespaceRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Create a new topic belonging to a namespace. */
    createTopic: {
      name: "CreateTopic",
      requestType: CreateTopicRequest,
      requestStream: false,
      responseType: Topic,
      responseStream: false,
      options: {},
    },
    /** Return the specified topic. */
    getTopic: {
      name: "GetTopic",
      requestType: GetTopicRequest,
      requestStream: false,
      responseType: Topic,
      responseStream: false,
      options: {},
    },
    /** List all topics belonging to a namespace. */
    listTopics: {
      name: "ListTopics",
      requestType: ListTopicsRequest,
      requestStream: false,
      responseType: ListTopicsResponse,
      responseStream: false,
      options: {},
    },
    /** Delete a topic. */
    deleteTopic: {
      name: "DeleteTopic",
      requestType: DeleteTopicRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Create a new object store belonging to a tenant. */
    createObjectStore: {
      name: "CreateObjectStore",
      requestType: CreateObjectStoreRequest,
      requestStream: false,
      responseType: ObjectStore,
      responseStream: false,
      options: {},
    },
    /** Return the specified object store. */
    getObjectStore: {
      name: "GetObjectStore",
      requestType: GetObjectStoreRequest,
      requestStream: false,
      responseType: ObjectStore,
      responseStream: false,
      options: {},
    },
    /** List all object stores belonging to a tenant. */
    listObjectStores: {
      name: "ListObjectStores",
      requestType: ListObjectStoresRequest,
      requestStream: false,
      responseType: ListObjectStoresResponse,
      responseStream: false,
      options: {},
    },
    /** Delete an object store. */
    deleteObjectStore: {
      name: "DeleteObjectStore",
      requestType: DeleteObjectStoreRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Create a new data lake belonging to a tenant. */
    createDataLake: {
      name: "CreateDataLake",
      requestType: CreateDataLakeRequest,
      requestStream: false,
      responseType: DataLake,
      responseStream: false,
      options: {},
    },
    /** Return the specified data lake. */
    getDataLake: {
      name: "GetDataLake",
      requestType: GetDataLakeRequest,
      requestStream: false,
      responseType: DataLake,
      responseStream: false,
      options: {},
    },
    /** List all data lakes belonging to a tenant. */
    listDataLakes: {
      name: "ListDataLakes",
      requestType: ListDataLakesRequest,
      requestStream: false,
      responseType: ListDataLakesResponse,
      responseStream: false,
      options: {},
    },
    /** Delete a data lake. */
    deleteDataLake: {
      name: "DeleteDataLake",
      requestType: DeleteDataLakeRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface ClusterMetadataServiceImplementation<CallContextExt = {}> {
  /** Create a new tenant. */
  createTenant(request: CreateTenantRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Tenant>>;
  /** Return the specified tenant. */
  getTenant(request: GetTenantRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Tenant>>;
  /** List all tenants. */
  listTenants(
    request: ListTenantsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListTenantsResponse>>;
  /**
   * Delete a tenant.
   *
   * The request fails if the tenant has any namespace.
   */
  deleteTenant(request: DeleteTenantRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Create a new namespace belonging to a tenant. */
  createNamespace(
    request: CreateNamespaceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Namespace>>;
  /** Return the specified namespace. */
  getNamespace(request: GetNamespaceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Namespace>>;
  /** List all namespaces belonging to a tenant. */
  listNamespaces(
    request: ListNamespacesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListNamespacesResponse>>;
  /**
   * Delete a namespace.
   *
   * The request fails if the namespace has any topic.
   */
  deleteNamespace(request: DeleteNamespaceRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Create a new topic belonging to a namespace. */
  createTopic(request: CreateTopicRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Topic>>;
  /** Return the specified topic. */
  getTopic(request: GetTopicRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Topic>>;
  /** List all topics belonging to a namespace. */
  listTopics(
    request: ListTopicsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListTopicsResponse>>;
  /** Delete a topic. */
  deleteTopic(request: DeleteTopicRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
  /** Create a new object store belonging to a tenant. */
  createObjectStore(
    request: CreateObjectStoreRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ObjectStore>>;
  /** Return the specified object store. */
  getObjectStore(
    request: GetObjectStoreRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ObjectStore>>;
  /** List all object stores belonging to a tenant. */
  listObjectStores(
    request: ListObjectStoresRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListObjectStoresResponse>>;
  /** Delete an object store. */
  deleteObjectStore(
    request: DeleteObjectStoreRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<Empty>>;
  /** Create a new data lake belonging to a tenant. */
  createDataLake(request: CreateDataLakeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<DataLake>>;
  /** Return the specified data lake. */
  getDataLake(request: GetDataLakeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<DataLake>>;
  /** List all data lakes belonging to a tenant. */
  listDataLakes(
    request: ListDataLakesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<ListDataLakesResponse>>;
  /** Delete a data lake. */
  deleteDataLake(request: DeleteDataLakeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<Empty>>;
}

export interface ClusterMetadataServiceClient<CallOptionsExt = {}> {
  /** Create a new tenant. */
  createTenant(request: DeepPartial<CreateTenantRequest>, options?: CallOptions & CallOptionsExt): Promise<Tenant>;
  /** Return the specified tenant. */
  getTenant(request: DeepPartial<GetTenantRequest>, options?: CallOptions & CallOptionsExt): Promise<Tenant>;
  /** List all tenants. */
  listTenants(
    request: DeepPartial<ListTenantsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListTenantsResponse>;
  /**
   * Delete a tenant.
   *
   * The request fails if the tenant has any namespace.
   */
  deleteTenant(request: DeepPartial<DeleteTenantRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Create a new namespace belonging to a tenant. */
  createNamespace(
    request: DeepPartial<CreateNamespaceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Namespace>;
  /** Return the specified namespace. */
  getNamespace(request: DeepPartial<GetNamespaceRequest>, options?: CallOptions & CallOptionsExt): Promise<Namespace>;
  /** List all namespaces belonging to a tenant. */
  listNamespaces(
    request: DeepPartial<ListNamespacesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListNamespacesResponse>;
  /**
   * Delete a namespace.
   *
   * The request fails if the namespace has any topic.
   */
  deleteNamespace(request: DeepPartial<DeleteNamespaceRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Create a new topic belonging to a namespace. */
  createTopic(request: DeepPartial<CreateTopicRequest>, options?: CallOptions & CallOptionsExt): Promise<Topic>;
  /** Return the specified topic. */
  getTopic(request: DeepPartial<GetTopicRequest>, options?: CallOptions & CallOptionsExt): Promise<Topic>;
  /** List all topics belonging to a namespace. */
  listTopics(
    request: DeepPartial<ListTopicsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListTopicsResponse>;
  /** Delete a topic. */
  deleteTopic(request: DeepPartial<DeleteTopicRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
  /** Create a new object store belonging to a tenant. */
  createObjectStore(
    request: DeepPartial<CreateObjectStoreRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ObjectStore>;
  /** Return the specified object store. */
  getObjectStore(
    request: DeepPartial<GetObjectStoreRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ObjectStore>;
  /** List all object stores belonging to a tenant. */
  listObjectStores(
    request: DeepPartial<ListObjectStoresRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListObjectStoresResponse>;
  /** Delete an object store. */
  deleteObjectStore(
    request: DeepPartial<DeleteObjectStoreRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<Empty>;
  /** Create a new data lake belonging to a tenant. */
  createDataLake(
    request: DeepPartial<CreateDataLakeRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<DataLake>;
  /** Return the specified data lake. */
  getDataLake(request: DeepPartial<GetDataLakeRequest>, options?: CallOptions & CallOptionsExt): Promise<DataLake>;
  /** List all data lakes belonging to a tenant. */
  listDataLakes(
    request: DeepPartial<ListDataLakesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<ListDataLakesResponse>;
  /** Delete a data lake. */
  deleteDataLake(request: DeepPartial<DeleteDataLakeRequest>, options?: CallOptions & CallOptionsExt): Promise<Empty>;
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { readonly $case: string }
    ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { readonly $case: T["$case"] }
  : T extends {} ? { [K in Exclude<keyof T, "$type">]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P> | "$type">]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
